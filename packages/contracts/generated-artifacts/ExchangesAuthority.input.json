{
	"language": "Solidity",
	"sources": {
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/protocol/authorities/ExchangesAuthority/ExchangesAuthority.sol": {
			"content": "/*\n\n Copyright 2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.0;\n\nimport { Owned } from \"../../../utils/Owned/Owned.sol\";\nimport { ExchangesAuthorityFace } from \"./ExchangesAuthorityFace.sol\";\n\n/// @title Exchanges Authority - A helper contract for the exchange adapters.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ncontract ExchangesAuthority is Owned, ExchangesAuthorityFace {\n\n    BuildingBlocks public blocks;\n    Type public types;\n\n    mapping (address => Account) public accounts;\n\n    struct List {\n        address target;\n    }\n\n    struct Type {\n        string types;\n        List[] list;\n    }\n\n    struct Group {\n        bool whitelister;\n        bool exchange;\n        bool asset;\n        bool authority;\n        bool wrapper;\n        bool proxy;\n    }\n\n    struct Account {\n        address account;\n        bool authorized;\n        mapping (bool => Group) groups; //mapping account to bool authorized to bool group\n    }\n\n    struct BuildingBlocks {\n        address exchangeEventful;\n        address sigVerifier;\n        address casper;\n        mapping (address => bool) initialized;\n        mapping (address => address) adapter;\n        // Mapping of exchange => method => approved\n        mapping (address => mapping (bytes4 => bool)) allowedMethods;\n        mapping (address => mapping (address => bool)) allowedTokens;\n        mapping (address => mapping (address => bool)) allowedWrappers;\n    }\n\n    /*\n     * EVENTS\n     */\n    event AuthoritySet(address indexed authority);\n    event WhitelisterSet(address indexed whitelister);\n    event WhitelistedAsset(address indexed asset, bool approved);\n    event WhitelistedExchange(address indexed exchange, bool approved);\n    event WhitelistedWrapper(address indexed wrapper, bool approved);\n    event WhitelistedProxy(address indexed proxy, bool approved);\n    event WhitelistedMethod(bytes4 indexed method, address indexed adapter, bool approved);\n    event NewSigVerifier(address indexed sigVerifier);\n    event NewExchangeEventful(address indexed exchangeEventful);\n    event NewCasper(address indexed casper);\n\n    /*\n     * MODIFIERS\n     */\n    modifier onlyAdmin {\n        require(msg.sender == owner || isWhitelister(msg.sender));\n        _;\n    }\n\n    modifier onlyWhitelister {\n        require(isWhitelister(msg.sender));\n        _;\n    }\n\n    /*\n     * CORE FUNCTIONS\n     */\n    /// @dev Allows the owner to whitelist an authority\n    /// @param _authority Address of the authority\n    /// @param _isWhitelisted Bool whitelisted\n    function setAuthority(address _authority, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        setAuthorityInternal(_authority, _isWhitelisted);\n    }\n\n    /// @dev Allows the owner to whitelist a whitelister\n    /// @param _whitelister Address of the whitelister\n    /// @param _isWhitelisted Bool whitelisted\n    function setWhitelister(address _whitelister, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        setWhitelisterInternal(_whitelister, _isWhitelisted);\n    }\n\n    /// @dev Allows a whitelister to whitelist an asset\n    /// @param _asset Address of the token\n    /// @param _isWhitelisted Bool whitelisted\n    function whitelistAsset(address _asset, bool _isWhitelisted)\n        external\n        onlyWhitelister\n    {\n        accounts[_asset].account = _asset;\n        accounts[_asset].authorized = _isWhitelisted;\n        accounts[_asset].groups[_isWhitelisted].asset = _isWhitelisted;\n        types.list.push(List(_asset));\n        emit WhitelistedAsset(_asset, _isWhitelisted);\n    }\n\n    /// @dev Allows a whitelister to whitelist an exchange\n    /// @param _exchange Address of the target exchange\n    /// @param _isWhitelisted Bool whitelisted\n    function whitelistExchange(address _exchange, bool _isWhitelisted)\n        external\n        onlyWhitelister\n    {\n        accounts[_exchange].account = _exchange;\n        accounts[_exchange].authorized = _isWhitelisted;\n        accounts[_exchange].groups[_isWhitelisted].exchange = _isWhitelisted;\n        types.list.push(List(_exchange));\n        emit WhitelistedExchange(_exchange, _isWhitelisted);\n    }\n\n    /// @dev Allows a whitelister to whitelist an token wrapper\n    /// @param _wrapper Address of the target token wrapper\n    /// @param _isWhitelisted Bool whitelisted\n    function whitelistWrapper(address _wrapper, bool _isWhitelisted)\n        external\n        onlyWhitelister\n    {\n        accounts[_wrapper].account = _wrapper;\n        accounts[_wrapper].authorized = _isWhitelisted;\n        accounts[_wrapper].groups[_isWhitelisted].wrapper = _isWhitelisted;\n        types.list.push(List(_wrapper));\n        emit WhitelistedWrapper(_wrapper, _isWhitelisted);\n    }\n\n    /// @dev Allows a whitelister to whitelist a tokenTransferProxy\n    /// @param _tokenTransferProxy Address of the proxy\n    /// @param _isWhitelisted Bool whitelisted\n    function whitelistTokenTransferProxy(\n        address _tokenTransferProxy,\n        bool _isWhitelisted)\n        external\n        onlyWhitelister\n    {\n        accounts[_tokenTransferProxy].account = _tokenTransferProxy;\n        accounts[_tokenTransferProxy].authorized = _isWhitelisted;\n        accounts[_tokenTransferProxy].groups[_isWhitelisted].proxy = _isWhitelisted;\n        types.list.push(List(_tokenTransferProxy));\n        emit WhitelistedProxy(_tokenTransferProxy, _isWhitelisted);\n    }\n\n    /// @dev Allows a whitelister to enable trading on a particular exchange\n    /// @param _asset Address of the token\n    /// @param _exchange Address of the exchange\n    /// @param _isWhitelisted Bool whitelisted\n    function whitelistAssetOnExchange(\n        address _asset,\n        address _exchange,\n        bool _isWhitelisted)\n        external\n        onlyAdmin\n    {\n        blocks.allowedTokens[_exchange][_asset] = _isWhitelisted;\n        emit WhitelistedAsset(_asset, _isWhitelisted);\n    }\n\n    /// @dev Allows a whitelister to enable assiciate wrappers to a token\n    /// @param _token Address of the token\n    /// @param _wrapper Address of the exchange\n    /// @param _isWhitelisted Bool whitelisted\n    function whitelistTokenOnWrapper(address _token, address _wrapper, bool _isWhitelisted)\n        external\n        onlyAdmin\n    {\n        blocks.allowedWrappers[_wrapper][_token] = _isWhitelisted;\n        emit WhitelistedAsset(_token, _isWhitelisted);\n    }\n\n    /// @dev Allows an admin to whitelist a factory\n    /// @param _method Hex of the function ABI\n    /// @param _isWhitelisted Bool whitelisted\n    function whitelistMethod(\n        bytes4 _method,\n        address _adapter,\n        bool _isWhitelisted)\n        external\n        onlyAdmin\n    {\n        blocks.allowedMethods[_adapter][_method] = _isWhitelisted;\n        emit WhitelistedMethod(_method, _adapter, _isWhitelisted);\n    }\n\n    /// @dev Allows the owner to set the signature verifier\n    /// @param _sigVerifier Address of the verifier contract\n    function setSignatureVerifier(address _sigVerifier)\n        external\n        onlyOwner\n    {\n        blocks.sigVerifier = _sigVerifier;\n        emit NewSigVerifier(blocks.sigVerifier);\n    }\n\n    /// @dev Allows the owner to set the exchange eventful\n    /// @param _exchangeEventful Address of the exchange logs contract\n    function setExchangeEventful(address _exchangeEventful)\n        external\n        onlyOwner\n    {\n        blocks.exchangeEventful = _exchangeEventful;\n        emit NewExchangeEventful(blocks.exchangeEventful);\n    }\n\n    /// @dev Allows the owner to associate an exchange to its adapter\n    /// @param _exchange Address of the exchange\n    /// @param _adapter Address of the adapter\n    function setExchangeAdapter(address _exchange, address _adapter)\n        external\n        onlyOwner\n    {\n        require(_exchange != _adapter);\n        blocks.adapter[_exchange] = _adapter;\n    }\n\n    /// @dev Allows the owner to set the casper contract\n    /// @param _casper Address of the casper contract\n    function setCasper(address _casper)\n        external\n        onlyOwner\n    {\n        blocks.casper = _casper;\n        blocks.initialized[_casper] = true;\n        emit NewCasper(blocks.casper);\n    }\n\n    /*\n     * CONSTANT PUBLIC FUNCTIONS\n     */\n    /// @dev Provides whether an address is an authority\n    /// @param _authority Address of the target authority\n    /// @return Bool is whitelisted\n    function isAuthority(address _authority)\n        external view\n        returns (bool)\n    {\n        return accounts[_authority].groups[true].authority;\n    }\n\n    /// @dev Provides whether an asset is whitelisted\n    /// @param _asset Address of the target asset\n    /// @return Bool is whitelisted\n    function isWhitelistedAsset(address _asset)\n        external view\n        returns (bool)\n    {\n        return accounts[_asset].groups[true].asset;\n    }\n\n    /// @dev Provides whether an exchange is whitelisted\n    /// @param _exchange Address of the target exchange\n    /// @return Bool is whitelisted\n    function isWhitelistedExchange(address _exchange)\n        external view\n        returns (bool)\n    {\n        return accounts[_exchange].groups[true].exchange;\n    }\n\n    /// @dev Provides whether a token wrapper is whitelisted\n    /// @param _wrapper Address of the target exchange\n    /// @return Bool is whitelisted\n    function isWhitelistedWrapper(address _wrapper)\n        external view\n        returns (bool)\n    {\n        return accounts[_wrapper].groups[true].wrapper;\n    }\n\n    /// @dev Provides whether a proxy is whitelisted\n    /// @param _tokenTransferProxy Address of the proxy\n    /// @return Bool is whitelisted\n    function isWhitelistedProxy(address _tokenTransferProxy)\n        external view\n        returns (bool)\n    {\n        return accounts[_tokenTransferProxy].groups[true].proxy;\n    }\n\n    /// @dev Provides the address of the exchange adapter\n    /// @param _exchange Address of the exchange\n    /// @return Address of the adapter\n    function getExchangeAdapter(address _exchange)\n        external view\n        returns (address)\n    {\n        return blocks.adapter[_exchange];\n    }\n\n    /// @dev Provides the address of the signature verifier\n    /// @return Address of the verifier\n    function getSigVerifier()\n        external view\n        returns (address)\n    {\n        return blocks.sigVerifier;\n    }\n\n    /// @dev Checkes whether a token is allowed on an exchange\n    /// @param _token Address of the token\n    /// @param _exchange Address of the exchange\n    /// @return Bool the token is whitelisted on the exchange\n    function canTradeTokenOnExchange(address _token, address _exchange)\n        external view\n        returns (bool)\n    {\n        return blocks.allowedTokens[_exchange][_token];\n    }\n\n    /// @dev Checkes whether a token is allowed on a wrapper\n    /// @param _token Address of the token\n    /// @param _wrapper Address of the token wrapper\n    /// @return Bool the token is whitelisted on the exchange\n    function canWrapTokenOnWrapper(address _token, address _wrapper)\n        external view\n        returns (bool)\n    {\n        return blocks.allowedWrappers[_wrapper][_token];\n    }\n\n    /// @dev Checkes whether a method is allowed on an exchange\n    /// @param _method Bytes of the function signature\n    /// @param _adapter Address of the exchange\n    /// @return Bool the method is allowed\n    function isMethodAllowed(bytes4 _method, address _adapter)\n        external view\n        returns (bool)\n    {\n        return blocks.allowedMethods[_adapter][_method];\n    }\n\n    /// @dev Checkes whether casper has been inizialized\n    /// @return Bool the casper contract has been initialized\n    function isCasperInitialized()\n        external view\n        returns (bool)\n    {\n        address casper = blocks.casper;\n        return blocks.initialized[casper];\n    }\n\n    /// @dev Provides the address of the casper contract\n    /// @return Address of the casper contract\n    function getCasper()\n        external view\n        returns (address)\n    {\n        return blocks.casper;\n    }\n\n    /*\n     * INTERNAL FUNCTIONS\n     */\n    /// @dev Allows to whitelist an authority\n    /// @param _authority Address of the authority\n    /// @param _isWhitelisted Bool whitelisted\n    function setAuthorityInternal(\n        address _authority,\n        bool _isWhitelisted)\n        internal\n    {\n        accounts[_authority].account = _authority;\n        accounts[_authority].authorized = _isWhitelisted;\n        accounts[_authority].groups[_isWhitelisted].authority = _isWhitelisted;\n        setWhitelisterInternal(_authority, _isWhitelisted);\n        types.list.push(List(_authority));\n        emit AuthoritySet(_authority);\n    }\n\n    /// @dev Allows the owner to whitelist a whitelister\n    /// @param _whitelister Address of the whitelister\n    /// @param _isWhitelisted Bool whitelisted\n    function setWhitelisterInternal(\n        address _whitelister,\n        bool _isWhitelisted)\n        internal\n    {\n        accounts[_whitelister].account = _whitelister;\n        accounts[_whitelister].authorized = _isWhitelisted;\n        accounts[_whitelister].groups[_isWhitelisted].whitelister = _isWhitelisted;\n        types.list.push(List(_whitelister));\n        emit WhitelisterSet(_whitelister);\n    }\n\n    /// @dev Provides whether an address is whitelister\n    /// @param _whitelister Address of the target whitelister\n    /// @return Bool is whitelisted\n    function isWhitelister(address _whitelister)\n        internal view\n        returns (bool)\n    {\n        return accounts[_whitelister].groups[true].whitelister;\n    }\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/utils/Owned/Owned.sol": {
			"content": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract Owned {\n\n    address public owner;\n\n    event NewOwner(address indexed old, address indexed current);\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setOwner(address _new)\n        public\n        onlyOwner\n    {\n        require(_new != address(0));\n        owner = _new;\n        emit NewOwner(owner, _new);\n    }\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/protocol/authorities/ExchangesAuthority/ExchangesAuthorityFace.sol": {
			"content": "/*\n\n Copyright 2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.0;\n\n/// @title Exchange Authority Interface - A helper contract for the exchange adapters.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ninterface ExchangesAuthorityFace {\n\n    /*\n     * EVENTS\n     */\n    event AuthoritySet(address indexed authority);\n    event WhitelisterSet(address indexed whitelister);\n    event WhitelistedAsset(address indexed asset, bool approved);\n    event WhitelistedExchange(address indexed exchange, bool approved);\n    event WhitelistedWrapper(address indexed wrapper, bool approved);\n    event WhitelistedProxy(address indexed proxy, bool approved);\n    event WhitelistedMethod(bytes4 indexed method, address indexed exchange, bool approved);\n    event NewSigVerifier(address indexed sigVerifier);\n    event NewExchangeEventful(address indexed exchangeEventful);\n    event NewCasper(address indexed casper);\n\n    /*\n     * CORE FUNCTIONS\n     */\n    /// @dev Allows the owner to whitelist an authority\n    /// @param _authority Address of the authority\n    /// @param _isWhitelisted Bool whitelisted\n    function setAuthority(address _authority, bool _isWhitelisted)\n        external;\n\n    /// @dev Allows the owner to whitelist a whitelister\n    /// @param _whitelister Address of the whitelister\n    /// @param _isWhitelisted Bool whitelisted\n    function setWhitelister(address _whitelister, bool _isWhitelisted)\n        external;\n\n    /// @dev Allows a whitelister to whitelist an asset\n    /// @param _asset Address of the token\n    /// @param _isWhitelisted Bool whitelisted\n    function whitelistAsset(address _asset, bool _isWhitelisted)\n        external;\n\n    /// @dev Allows a whitelister to whitelist an exchange\n    /// @param _exchange Address of the target exchange\n    /// @param _isWhitelisted Bool whitelisted\n    function whitelistExchange(address _exchange, bool _isWhitelisted)\n        external;\n\n    /// @dev Allows a whitelister to whitelist an token wrapper\n    /// @param _wrapper Address of the target token wrapper\n    /// @param _isWhitelisted Bool whitelisted\n    function whitelistWrapper(address _wrapper, bool _isWhitelisted)\n        external;\n\n    /// @dev Allows a whitelister to whitelist a tokenTransferProxy\n    /// @param _tokenTransferProxy Address of the proxy\n    /// @param _isWhitelisted Bool whitelisted\n    function whitelistTokenTransferProxy(\n        address _tokenTransferProxy, bool _isWhitelisted)\n        external;\n\n    /// @dev Allows a whitelister to enable trading on a particular exchange\n    /// @param _asset Address of the token\n    /// @param _exchange Address of the exchange\n    /// @param _isWhitelisted Bool whitelisted\n    function whitelistAssetOnExchange(\n        address _asset,\n        address _exchange,\n        bool _isWhitelisted)\n        external;\n\n    /// @dev Allows a whitelister to enable assiciate wrappers to a token\n    /// @param _token Address of the token\n    /// @param _wrapper Address of the exchange\n    /// @param _isWhitelisted Bool whitelisted\n    function whitelistTokenOnWrapper(\n        address _token,\n        address _wrapper,\n        bool _isWhitelisted)\n        external;\n\n    /// @dev Allows an admin to whitelist a factory\n    /// @param _method Hex of the function ABI\n    /// @param _isWhitelisted Bool whitelisted\n    function whitelistMethod(\n        bytes4 _method,\n        address _adapter,\n        bool _isWhitelisted)\n        external;\n\n    /// @dev Allows the owner to set the signature verifier\n    /// @param _sigVerifier Address of the logs contract\n    function setSignatureVerifier(address _sigVerifier)\n        external;\n\n    /// @dev Allows the owner to set the exchange eventful\n    /// @param _exchangeEventful Address of the exchange logs contract\n    function setExchangeEventful(address _exchangeEventful)\n        external;\n\n    /// @dev Allows the owner to associate an exchange to its adapter\n    /// @param _exchange Address of the exchange\n    /// @param _adapter Address of the adapter\n    function setExchangeAdapter(address _exchange, address _adapter)\n        external;\n\n    /// @dev Allows the owner to set the casper contract\n    /// @param _casper Address of the casper contract\n    function setCasper(address _casper)\n        external;\n\n    /*\n     * CONSTANT PUBLIC FUNCTIONS\n     */\n    /// @dev Provides whether an address is an authority\n    /// @param _authority Address of the target authority\n    /// @return Bool is whitelisted\n    function isAuthority(address _authority)\n        external view\n        returns (bool);\n\n    /// @dev Provides whether an asset is whitelisted\n    /// @param _asset Address of the target asset\n    /// @return Bool is whitelisted\n    function isWhitelistedAsset(address _asset)\n        external view\n        returns (bool);\n\n    /// @dev Provides whether an exchange is whitelisted\n    /// @param _exchange Address of the target exchange\n    /// @return Bool is whitelisted\n    function isWhitelistedExchange(address _exchange)\n        external view\n        returns (bool);\n\n    /// @dev Provides whether a token wrapper is whitelisted\n    /// @param _wrapper Address of the target exchange\n    /// @return Bool is whitelisted\n    function isWhitelistedWrapper(address _wrapper)\n        external view\n        returns (bool);\n\n    /// @dev Provides whether a proxy is whitelisted\n    /// @param _tokenTransferProxy Address of the proxy\n    /// @return Bool is whitelisted\n    function isWhitelistedProxy(address _tokenTransferProxy)\n        external view\n        returns (bool);\n\n    /// @dev Provides the address of the exchange adapter\n    /// @param _exchange Address of the exchange\n    /// @return Address of the adapter\n    function getExchangeAdapter(address _exchange)\n        external view\n        returns (address);\n\n    /// @dev Provides the address of the signature verifier\n    /// @return Address of the verifier\n    function getSigVerifier()\n        external view\n        returns (address);\n\n    /// @dev Checkes whether a token is allowed on an exchange\n    /// @param _token Address of the token\n    /// @param _exchange Address of the exchange\n    /// @return Bool the token is whitelisted on the exchange\n    function canTradeTokenOnExchange(address _token, address _exchange)\n        external view\n        returns (bool);\n\n    /// @dev Checkes whether a token is allowed on a wrapper\n    /// @param _token Address of the token\n    /// @return Bool the token is whitelisted on the exchange\n    function canWrapTokenOnWrapper(address _token, address _wrapper)\n        external view\n        returns (bool);\n\n    /// @dev Checkes whether a method is allowed on an exchange\n    function isMethodAllowed(bytes4 _method, address _exchange)\n        external view\n        returns (bool);\n\n    /// @dev Checkes whether casper has been inizialized\n    /// @return Bool the casper contract has been initialized\n    function isCasperInitialized()\n        external view\n        returns (bool);\n\n    /// @dev Provides the address of the casper contract\n    /// @return Address of the casper contract\n    function getCasper()\n        external view\n        returns (address);\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/examples/Faucet/Faucet.sol": {
			"content": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\n/**\n * Faucet smart contract for RigoBlock protocol\n * allows users to receive erc20Basic tokens\n * Inspired by https://github.com/AvocadoNetwork\n */\n\npragma solidity 0.5.0;\n\nimport { ERC20Face as Token } from \"../../tokens/ERC20/ERC20Face.sol\";\nimport { Owned as Owned } from \"../../utils/Owned/Owned.sol\";\n\n/// @title Faucet - Allows to automatically distribute GRGs.\n/// @author David Fava - <david@rigoblock.com>\ncontract Faucet is Owned {\n\n\n   /*\n    * EVENTS\n    */\n    event Deposit(address indexed sender, uint256 value);\n    event OneTokenSent(address indexed receiver);\n    event FaucetOn(bool status);\n    event FaucetOff(bool status);\n\n    uint256 constant oneToken = 1000000000000000000;\n    uint256 constant twentyFourHours = 24 hours;\n    string public faucetName;\n    Token public tokenInstance;\n    bool public faucetStatus;\n    mapping(address => uint256) status;\n\n\n   /*\n    * MODIFIERS\n    */\n    modifier faucetOn() {\n        require(faucetStatus,\"Faucet has to be on\");\n        _;\n    }\n\n    modifier faucetOff() {\n        require(!faucetStatus, \"Faucet has to be off\");\n        _;\n    }\n\n    /// @dev Contract constructor\n    /// @param _tokenInstance address of ERC20Basic token\n    /// @param _faucetName sets the name for the faucet\n    constructor(address _tokenInstance, string memory _faucetName)\n      public\n    {\n        tokenInstance = Token(_tokenInstance);\n        faucetName = _faucetName;\n        faucetStatus = true;\n\n        emit FaucetOn(faucetStatus);\n    }\n\n   /*\n    * CORE FUNCTIONS\n    */\n    /// @dev send 1000 Token with a minimum time lock of 1 hour\n    /// @return bool on success\n    function drip1Token()\n      external\n      faucetOn\n      returns (bool success)\n    {\n        require(!checkStatus(msg.sender),\"Required too early.\");\n        updateStatus(msg.sender, twentyFourHours);\n        tokenInstance.transfer(msg.sender, oneToken);\n        emit OneTokenSent(msg.sender);\n        return true;\n    }\n\n    /// @dev turn faucet on\n    /// @return bool on success\n    function turnFaucetOn()\n      external\n      onlyOwner\n      faucetOff\n      returns (bool success)\n    {\n        faucetStatus = true;\n        emit FaucetOn(faucetStatus);\n        return true;\n    }\n\n    /// @dev turn faucet off\n    /// @return bool on success\n    function turnFaucetOff()\n      external\n      onlyOwner\n      faucetOn\n      returns (bool success)\n    {\n        faucetStatus = false;\n        emit FaucetOff(faucetStatus);\n        return true;\n    }\n\n    /// @dev allow withdrawal from the owner\n    /// @return bool on success\n    function withdraw(\n        uint _value\n    )\n        external\n        onlyOwner\n        returns\n        (bool success)\n    {\n        require(tokenInstance.transfer(msg.sender, _value),\"Cannot withdraw.\");\n        return true;\n    }\n\n    /*\n     * INTERNAL FUNCTIONS\n     */\n    /// @dev locks and unlocks account based on time range\n    /// @param _address of msg.sender\n    /// @return bool of current lock status of address\n    function checkStatus(address _address)\n      internal\n      view\n      returns (bool)\n    {\n        //check if first time address is requesting\n        if(status[_address] == 0) {\n            return false;\n        }\n        //if not first time check the timeLock\n        else {\n            // solium-disable-next-line security/no-block-members\n            if(block.timestamp >= status[_address]) {\n                return false;\n            }\n            else {\n                return true;\n            }\n        }\n    }\n\n    /// @dev updates timeLock for account\n    /// @param _address of msg.sender\n    /// @param _timelock of sender address\n    /// @return bool on success\n    function updateStatus(address _address, uint256 _timelock)\n      internal\n      returns (bool)\n    {   // solium-disable-next-line security/no-block-members\n        status[_address] = block.timestamp + _timelock;\n        return true;\n    }\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/tokens/ERC20/ERC20Face.sol": {
			"content": "pragma solidity >=0.5.0;\n\ninterface ERC20Face {\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function balanceOf(address _who) external view returns (uint256);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n}\n"
		}
	},
	"settings": {
		"remappings": [],
		"optimizer": {
			"enabled": true,
			"runs": 1000000
		},
		"outputSelection": {
			"*": {
				"*": [
					"abi",
					"devdoc",
					"evm.bytecode.object",
					"evm.bytecode.sourceMap",
					"evm.deployedBytecode.object",
					"evm.deployedBytecode.sourceMap"
				]
			}
		},
		"version": "0.5.0+commit.1d4f565a"
	}
}