{
	"language": "Solidity",
	"sources": {
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/protocol/authorities/Authority/Authority.sol": {
			"content": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.0;\n\nimport { Owned } from \"../../../utils/Owned/Owned.sol\";\nimport { AuthorityFace } from \"./AuthorityFace.sol\";\n\n/// @title Authority - Allows to set up the base rules of the protocol.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ncontract Authority is\n    Owned,\n    AuthorityFace\n{\n    BuildingBlocks public blocks;\n    Type public types;\n\n    mapping (address => Account) public accounts;\n\n    struct List {\n        address target;\n    }\n\n    struct Type {\n        string types;\n        List[] list;\n    }\n\n    struct Group {\n        bool whitelister;\n        bool drago;\n        bool vault;\n        bool user;\n        bool registry;\n        bool factory;\n        bool authority;\n    }\n\n    struct Account {\n        address account;\n        bool authorized;\n        mapping (bool => Group) groups; //mapping account to bool authorized to bool group\n    }\n\n    struct BuildingBlocks {\n        address dragoEventful;\n        address vaultEventful;\n        address navVerifier;\n        address exchangesAuthority;\n        address casper;\n        mapping (address => bool) initialized;\n    }\n\n    /*\n     * EVENTS\n     */\n    event AuthoritySet(address indexed authority);\n    event WhitelisterSet(address indexed whitelister);\n    event WhitelistedUser(address indexed target, bool approved);\n    event WhitelistedRegistry(address indexed registry, bool approved);\n    event WhitelistedFactory(address indexed factory, bool approved);\n    event WhitelistedVault(address indexed vault, bool approved);\n    event WhitelistedDrago(address indexed drago, bool isWhitelisted);\n    event NewDragoEventful(address indexed dragoEventful);\n    event NewVaultEventful(address indexed vaultEventful);\n    event NewNavVerifier(address indexed navVerifier);\n    event NewExchangesAuthority(address indexed exchangesAuthority);\n\n    /*\n     * MODIFIERS\n     */\n    modifier onlyAdmin {\n        require(msg.sender == owner || isWhitelister(msg.sender));\n        _;\n    }\n\n    modifier onlyWhitelister {\n        require(isWhitelister(msg.sender));\n        _;\n    }\n\n    /*\n     * CORE FUNCTIONS\n     */\n    /// @dev Allows the owner to whitelist an authority\n    /// @param _authority Address of the authority\n    /// @param _isWhitelisted Bool whitelisted\n    function setAuthority(address _authority, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        setAuthorityInternal(_authority, _isWhitelisted);\n    }\n\n    /// @dev Allows the owner to whitelist a whitelister\n    /// @param _whitelister Address of the whitelister\n    /// @param _isWhitelisted Bool whitelisted\n    function setWhitelister(address _whitelister, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        setWhitelisterInternal(_whitelister, _isWhitelisted);\n    }\n\n    /// @dev Allows a whitelister to whitelist a user\n    /// @param _target Address of the target user\n    /// @param _isWhitelisted Bool whitelisted\n    function whitelistUser(address _target, bool _isWhitelisted)\n        external\n        onlyWhitelister\n    {\n        accounts[_target].account = _target;\n        accounts[_target].authorized = _isWhitelisted;\n        accounts[_target].groups[_isWhitelisted].user = _isWhitelisted;\n        types.list.push(List(_target));\n        emit WhitelistedUser(_target, _isWhitelisted);\n    }\n\n    /// @dev Allows an admin to whitelist a drago\n    /// @param _drago Address of the target drago\n    /// @param _isWhitelisted Bool whitelisted\n    function whitelistDrago(address _drago, bool _isWhitelisted)\n        external\n        onlyAdmin\n    {\n        accounts[_drago].account = _drago;\n        accounts[_drago].authorized = _isWhitelisted;\n        accounts[_drago].groups[_isWhitelisted].drago = _isWhitelisted;\n        types.list.push(List(_drago));\n        emit WhitelistedDrago(_drago, _isWhitelisted);\n    }\n\n    /// @dev Allows an admin to whitelist a vault\n    /// @param _vault Address of the target vault\n    /// @param _isWhitelisted Bool whitelisted\n    function whitelistVault(address _vault, bool _isWhitelisted)\n        external\n        onlyAdmin\n    {\n        accounts[_vault].account = _vault;\n        accounts[_vault].authorized = _isWhitelisted;\n        accounts[_vault].groups[_isWhitelisted].vault = _isWhitelisted;\n        types.list.push(List(_vault));\n        emit WhitelistedVault(_vault, _isWhitelisted);\n    }\n\n    /// @dev Allows an admin to whitelist a registry\n    /// @param _registry Address of the target registry\n    /// @param _isWhitelisted Bool whitelisted\n    function whitelistRegistry(address _registry, bool _isWhitelisted)\n        external\n        onlyAdmin\n    {\n        accounts[_registry].account = _registry;\n        accounts[_registry].authorized = _isWhitelisted;\n        accounts[_registry].groups[_isWhitelisted].registry = _isWhitelisted;\n        types.list.push(List(_registry));\n        emit WhitelistedRegistry(_registry, _isWhitelisted);\n    }\n\n    /// @dev Allows an admin to whitelist a factory\n    /// @param _factory Address of the target factory\n    /// @param _isWhitelisted Bool whitelisted\n    function whitelistFactory(address _factory, bool _isWhitelisted)\n        external\n        onlyAdmin\n    {\n        accounts[_factory].account = _factory;\n        accounts[_factory].authorized = _isWhitelisted;\n        accounts[_factory].groups[_isWhitelisted].registry = _isWhitelisted;\n        types.list.push(List(_factory));\n        setAuthorityInternal(_factory, _isWhitelisted);\n        emit WhitelistedFactory(_factory, _isWhitelisted);\n    }\n\n    /// @dev Allows the owner to set the drago eventful\n    /// @param _dragoEventful Address of the logs contract\n    function setDragoEventful(address _dragoEventful)\n        external\n        onlyOwner\n    {\n        blocks.dragoEventful = _dragoEventful;\n        emit NewDragoEventful(blocks.dragoEventful);\n    }\n\n    /// @dev Allows the owner to set the vault eventful\n    /// @param _vaultEventful Address of the vault logs contract\n    function setVaultEventful(address _vaultEventful)\n        external\n        onlyOwner\n    {\n        blocks.vaultEventful = _vaultEventful;\n        emit NewVaultEventful(blocks.vaultEventful);\n    }\n\n    /// @dev Allows the owner to set the nav verifier\n    /// @param _navVerifier Address of the verifier\n    function setNavVerifier(address _navVerifier)\n        external\n        onlyOwner\n    {\n        blocks.navVerifier = _navVerifier;\n        emit NewNavVerifier(blocks.navVerifier);\n    }\n\n    /// @dev Allows the owner to set the exchanges authority\n    /// @param _exchangesAuthority Address of the exchanges authority\n    function setExchangesAuthority(address _exchangesAuthority)\n        external\n        onlyOwner\n    {\n        blocks.exchangesAuthority = _exchangesAuthority;\n        emit NewExchangesAuthority(blocks.exchangesAuthority);\n    }\n\n    /*\n     * CONSTANT PUBLIC FUNCTIONS\n     */\n    /// @dev Provides whether a user is whitelisted\n    /// @param _target Address of the target user\n    /// @return Bool is whitelisted\n    function isWhitelistedUser(address _target)\n        external view\n        returns (bool)\n    {\n        return accounts[_target].groups[true].user;\n    }\n\n    /// @dev Provides whether an address is an authority\n    /// @param _authority Address of the target authority\n    /// @return Bool is whitelisted\n    function isAuthority(address _authority)\n        external view\n        returns (bool)\n    {\n        return accounts[_authority].groups[true].authority;\n    }\n\n    /// @dev Provides whether a drago is whitelisted\n    /// @param _drago Address of the target drago\n    /// @return Bool is whitelisted\n    function isWhitelistedDrago(address _drago)\n        external view\n        returns (bool)\n    {\n        return accounts[_drago].groups[true].drago;\n    }\n\n    /// @dev Provides whether a vault is whitelisted\n    /// @param _vault Address of the target vault\n    /// @return Bool is whitelisted\n    function isWhitelistedVault(address _vault)\n        external view\n        returns (bool)\n    {\n        return accounts[_vault].groups[true].vault;\n    }\n\n    /// @dev Provides whether a registry is whitelisted\n    /// @param _registry Address of the target registry\n    /// @return Bool is whitelisted\n    function isWhitelistedRegistry(address _registry)\n        external view\n        returns (bool)\n    {\n        return accounts[_registry].groups[true].registry;\n    }\n\n    /// @dev Provides whether a factory is whitelisted\n    /// @param _factory Address of the target factory\n    /// @return Bool is whitelisted\n    function isWhitelistedFactory(address _factory)\n        external view\n        returns (bool)\n    {\n        return accounts[_factory].groups[true].registry;\n    }\n\n    /// @dev Provides the address of the drago logs contract\n    /// @return Address of the drago logs contract\n    function getDragoEventful()\n        external view\n        returns (address)\n    {\n        return blocks.dragoEventful;\n    }\n\n    /// @dev Provides the address of the vault logs contract\n    /// @return Address of the vault logs contract\n    function getVaultEventful()\n        external view\n        returns (address)\n    {\n        return blocks.vaultEventful;\n    }\n\n    /// @dev Provides the address of the nav verifier\n    /// @return Address of the verifier\n    function getNavVerifier()\n        external view\n        returns (address)\n    {\n        return blocks.navVerifier;\n    }\n\n    /// @dev Provides the address of the exchangee authority\n    /// @return Address of the adapter\n    function getExchangesAuthority()\n        external view\n        returns (address)\n    {\n        return blocks.exchangesAuthority;\n    }\n\n    /*\n     * INTERNAL FUNCTIONS\n     */\n    /// @dev Allows to whitelist an authority\n    /// @param _authority Address of the authority\n    /// @param _isWhitelisted Bool whitelisted\n    function setAuthorityInternal(\n        address _authority,\n        bool _isWhitelisted)\n        internal\n    {\n        accounts[_authority].account = _authority;\n        accounts[_authority].authorized = _isWhitelisted;\n        accounts[_authority].groups[_isWhitelisted].authority = _isWhitelisted;\n        setWhitelisterInternal(_authority, _isWhitelisted);\n        types.list.push(List(_authority));\n        emit AuthoritySet(_authority);\n    }\n\n    /// @dev Allows the owner to whitelist a whitelister\n    /// @param _whitelister Address of the whitelister\n    /// @param _isWhitelisted Bool whitelisted\n    function setWhitelisterInternal(\n        address _whitelister,\n        bool _isWhitelisted)\n        internal\n    {\n        accounts[_whitelister].account = _whitelister;\n        accounts[_whitelister].authorized = _isWhitelisted;\n        accounts[_whitelister].groups[_isWhitelisted].whitelister = _isWhitelisted;\n        types.list.push(List(_whitelister));\n        emit WhitelisterSet(_whitelister);\n    }\n\n    /// @dev Provides whether an address is whitelister\n    /// @param _whitelister Address of the target whitelister\n    /// @return Bool is whitelisted\n    function isWhitelister(address _whitelister)\n        internal view\n        returns (bool)\n    {\n        return accounts[_whitelister].groups[true].whitelister;\n    }\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/utils/Owned/Owned.sol": {
			"content": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract Owned {\n\n    address public owner;\n\n    event NewOwner(address indexed old, address indexed current);\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setOwner(address _new)\n        public\n        onlyOwner\n    {\n        require(_new != address(0));\n        owner = _new;\n        emit NewOwner(owner, _new);\n    }\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/protocol/authorities/Authority/AuthorityFace.sol": {
			"content": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity >=0.4.22 <0.6.0;\n\n/// @title Authority Interface - Allows interaction with the Authority contract.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ninterface AuthorityFace {\n\n    /*\n     * EVENTS\n     */\n    event AuthoritySet(address indexed authority);\n    event WhitelisterSet(address indexed whitelister);\n    event WhitelistedUser(address indexed target, bool approved);\n    event WhitelistedRegistry(address indexed registry, bool approved);\n    event WhitelistedFactory(address indexed factory, bool approved);\n    event WhitelistedVault(address indexed vault, bool approved);\n    event WhitelistedDrago(address indexed drago, bool isWhitelisted);\n    event NewDragoEventful(address indexed dragoEventful);\n    event NewVaultEventful(address indexed vaultEventful);\n    event NewNavVerifier(address indexed navVerifier);\n    event NewExchangesAuthority(address indexed exchangesAuthority);\n\n    /*\n     * CORE FUNCTIONS\n     */\n    function setAuthority(address _authority, bool _isWhitelisted) external;\n    function setWhitelister(address _whitelister, bool _isWhitelisted) external;\n    function whitelistUser(address _target, bool _isWhitelisted) external;\n    function whitelistDrago(address _drago, bool _isWhitelisted) external;\n    function whitelistVault(address _vault, bool _isWhitelisted) external;\n    function whitelistRegistry(address _registry, bool _isWhitelisted) external;\n    function whitelistFactory(address _factory, bool _isWhitelisted) external;\n    function setDragoEventful(address _dragoEventful) external;\n    function setVaultEventful(address _vaultEventful) external;\n    function setNavVerifier(address _navVerifier) external;\n    function setExchangesAuthority(address _exchangesAuthority) external;\n\n    /*\n     * CONSTANT PUBLIC FUNCTIONS\n     */\n    function isWhitelistedUser(address _target) external view returns (bool);\n    function isAuthority(address _authority) external view returns (bool);\n    function isWhitelistedRegistry(address _registry) external view returns (bool);\n    function isWhitelistedDrago(address _drago) external view returns (bool);\n    function isWhitelistedVault(address _vault) external view returns (bool);\n    function isWhitelistedFactory(address _factory) external view returns (bool);\n    function getDragoEventful() external view returns (address);\n    function getVaultEventful() external view returns (address);\n    function getNavVerifier() external view returns (address);\n    function getExchangesAuthority() external view returns (address);\n}\n"
		}
	},
	"settings": {
		"remappings": [],
		"optimizer": {
			"enabled": true,
			"runs": 1000000
		},
		"outputSelection": {
			"*": {
				"*": [
					"abi",
					"devdoc",
					"evm.bytecode.object",
					"evm.bytecode.sourceMap",
					"evm.deployedBytecode.object",
					"evm.deployedBytecode.sourceMap"
				]
			}
		},
		"version": "0.5.0+commit.1d4f565a"
	}
}