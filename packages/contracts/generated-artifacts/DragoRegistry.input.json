{
	"language": "Solidity",
	"sources": {
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/protocol/DragoRegistry/DragoRegistry.sol": {
			"content": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.0;\n\nimport { Owned } from \"../../utils/Owned/Owned.sol\";\nimport { DragoRegistryFace } from \"./DragoRegistryFace.sol\";\nimport { AuthorityFace as Authority } from \"../authorities/Authority/AuthorityFace.sol\";\nimport { LibSanitize } from \"../../utils/LibSanitize/LibSanitize.sol\";\n\n/// @title Drago Registry - Allows registration of pools.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ncontract DragoRegistry is DragoRegistryFace, Owned {\n\n    using LibSanitize for bool;\n\n    address public AUTHORITY;\n    uint256 public VERSION;\n\n    uint256 public fee = 0;\n\n    address[] groups;\n\n    Drago[] dragos;\n\n    mapping (bytes32 => address) mapFromKey;\n    mapping (address => uint256) mapFromAddress;\n    mapping (string => uint256) mapFromName;\n\n    struct Drago {\n        address drago;\n        string name;\n        string symbol;\n        uint256 dragoId;\n        address owner;\n        address group;\n        mapping (bytes32 => bytes32) meta;\n    }\n\n    /*\n     * EVENTS\n     */\n    event Registered(string name, string symbol, uint256 id, address indexed drago, address indexed owner, address indexed group);\n    event Unregistered(string indexed name, string indexed symbol, uint256 indexed id);\n    event MetaChanged(uint256 indexed id, bytes32 indexed key, bytes32 value);\n\n    /*\n     * MODIFIERS\n     */\n    modifier whenFeePaid {\n        require(msg.value >= fee);\n        _;\n    }\n\n    modifier whenAddressFree(address _drago) {\n        require(mapFromAddress[_drago] == 0);\n        _;\n    }\n\n    modifier onlyDragoOwner(uint256 _id) {\n        require(dragos[_id].owner == msg.sender);\n        _;\n    }\n\n    modifier whenNameFree(string memory _name) {\n        require(mapFromName[_name] == 0);\n        _;\n    }\n\n    modifier whenNameSanitized(string memory _input) {\n        require(bytes(_input).length >= 4 && bytes(_input).length <= 50);\n        require(LibSanitize.isValidCheck(_input));\n        _;\n    }\n\n    modifier whenSymbolSanitized(string memory _input) {\n        require(bytes(_input).length >= 3 && bytes(_input).length <= 5);\n        require(LibSanitize.isValidCheck(_input));\n        require(LibSanitize.isUppercase(_input));\n        _;\n    }\n\n    modifier whenHasName(string memory _name) {\n        require(mapFromName[_name] != 0);\n        _;\n    }\n\n    modifier onlyAuthority {\n        Authority auth = Authority(AUTHORITY);\n        require(auth.isAuthority(msg.sender) == true);\n        _;\n    }\n\n    constructor(address _authority) public {\n        AUTHORITY = _authority;\n    }\n\n    /*\n     * CORE FUNCTIONS\n     */\n    /// @dev Allows a factory which is an authority to register a pool\n    /// @param _drago Address of the pool\n    /// @param _name Name of the pool\n    /// @param _symbol Symbol of the pool\n    /// @param _dragoId Id number of the pool\n    /// @param _owner Address of the pool owner\n    function register(\n        address _drago,\n        string calldata _name,\n        string calldata _symbol,\n        uint256 _dragoId,\n        address _owner)\n        external\n        payable\n        onlyAuthority\n        whenFeePaid\n        whenAddressFree(_drago)\n        whenNameSanitized(_name)\n        whenSymbolSanitized(_symbol)\n        whenNameFree(_name)\n        returns (bool)\n    {\n        return registerAs(_drago, _name, _symbol, _dragoId, _owner, msg.sender);\n    }\n\n    /// @dev Allows owner to unregister a pool\n    /// @param _id Number of the pool\n    function unregister(uint256 _id)\n        external\n        onlyOwner\n    {\n        emit Unregistered(dragos[_id].name, dragos[_id].symbol, _id);\n        delete mapFromAddress[dragos[_id].drago];\n        delete mapFromName[dragos[_id].name];\n        delete dragos[_id];\n    }\n\n    /// @dev Allows pool owner to set metadata for a pool\n    /// @param _id Number corresponding to pool id\n    /// @param _key Bytes32 of the key\n    /// @param _value Bytes32 of the value\n    function setMeta(uint256 _id, bytes32 _key, bytes32 _value)\n        external\n        onlyDragoOwner(_id)\n    {\n        dragos[_id].meta[_key] = _value;\n        emit MetaChanged(_id, _key, _value);\n    }\n\n    /// @dev Allows owner to add a group of pools (a factory)\n    /// @param _group Address of the new group\n    function addGroup(address _group)\n        external\n        onlyOwner\n    {\n        groups.push(_group);\n    }\n\n    /// @dev Allows owner to set a fee to register pools\n    /// @param _fee Value of the fee in wei\n    function setFee(uint256 _fee)\n        external\n        onlyOwner\n    {\n        fee = _fee;\n    }\n\n    /// @dev Allows anyone to update the owner in the registry\n    /// @notice pool owner can change; gets written in registry only when needed\n    /// @param _id uint256 of the target pool\n    function updateOwner(uint256 _id)\n        external\n    {\n        updateOwnerInternal(_id);\n    }\n\n    /// @dev Allows anyone to update many owners if they differ from registered\n    /// @param _id uint256 of the target pool\n    function updateOwners(uint256[] calldata _id)\n        external\n    {\n        for (uint256 i = 0; i < _id.length; ++i) {\n            if (!updateOwnerInternal(_id[i])) continue;\n        }\n    }\n\n    /// @dev Allows owner to create a new registry.\n    /// @dev When the registry gets upgraded, a migration of all funds is required\n    /// @param _newAddress Address of new registry.\n    function upgrade(address _newAddress)\n        external\n        payable\n        onlyOwner\n    {\n        DragoRegistry registry = DragoRegistry(_newAddress);\n        ++VERSION;\n        registry.setUpgraded(VERSION);\n        address payable registryAddress = address(uint160(address(registry)));\n        registryAddress.transfer(address(this).balance);\n    }\n\n    /// @dev Allows owner to update version on registry upgrade\n    /// @param _version Number of the new version\n    function setUpgraded(uint256 _version)\n        external\n        onlyOwner\n    {\n        VERSION = _version;\n    }\n\n    /// @dev Allows owner to collect fees by draining the balance\n    function drain()\n        external\n        onlyOwner\n    {\n        msg.sender.transfer(address(this).balance);\n    }\n\n    /*\n     * CONSTANT PUBLIC FUNCTIONS\n     */\n    /// @dev Provides the total number of registered pools\n    /// @return Number of pools\n    function dragoCount()\n        external view\n        returns (uint256)\n    {\n        return dragos.length;\n    }\n\n    /// @dev Provides a pool's struct data\n    /// @param _id Registration number of the pool\n    /// @return Pool struct data\n    function fromId(uint256 _id)\n        public view //prev external\n        returns (\n            address drago,\n            string memory name,\n            string memory symbol,\n            uint256 dragoId,\n            address owner,\n            address group\n        )\n    {\n        Drago memory pool = dragos[_id];\n        return (\n            drago = pool.drago,\n            name = pool.name,\n            symbol = pool.symbol,\n            dragoId = pool.dragoId,\n            owner = getPoolOwner(drago),\n            group = pool.group\n        );\n    }\n\n    /// @dev Provides a pool's struct data\n    /// @param _drago Address of the pool\n    /// @return Pool struct data\n    function fromAddress(address _drago)\n        external view\n        returns (\n            uint256 id,\n            string memory name,\n            string memory symbol,\n            uint256 dragoId,\n            address owner,\n            address group\n        )\n    {\n        id = mapFromAddress[_drago] - 1;\n        Drago memory pool = dragos[id];\n        return (\n            id,\n            name = pool.name,\n            symbol = pool.symbol,\n            dragoId = pool.dragoId,\n            owner = getPoolOwner(_drago),\n            group = pool.group\n        );\n    }\n\n    /// @dev Provides a pool's struct data\n    /// @param _name Name of the pool\n    /// @return Pool struct data\n    function fromName(string calldata _name)\n        external view\n        returns (\n            uint256 id,\n            address drago,\n            string memory symbol,\n            uint256 dragoId,\n            address owner,\n            address group\n        )\n    {\n        id = mapFromName[_name] - 1;\n        Drago memory pool = dragos[id];\n        return (\n            id,\n            drago = pool.drago,\n            symbol = pool.symbol,\n            dragoId = pool.dragoId,\n            owner = getPoolOwner(drago),\n            group = pool.group\n        );\n    }\n\n    /// @dev Provides a pool's name from its address\n    /// @param _pool Address of the pool\n    /// @return Name of the pool\n    function getNameFromAddress(address _pool)\n        external view\n        returns (string memory)\n    {\n        uint256 id = mapFromAddress[_pool] - 1;\n        Drago memory pool = dragos[id];\n        return pool.name;\n    }\n\n    /// @dev Provides a pool's symbol from its address\n    /// @param _pool Address of the pool\n    /// @return Symbol of the pool\n    function getSymbolFromAddress(address _pool)\n        external view\n        returns (string memory)\n    {\n        uint256 id = mapFromAddress[_pool] - 1;\n        Drago memory pool = dragos[id];\n        return pool.symbol;\n    }\n\n    /// @dev Provides a pool's metadata\n    /// @param _id Id number of the pool\n    /// @param _key Bytes32 key\n    /// @return Pool metadata\n    function meta(uint256 _id, bytes32 _key)\n        external view\n        returns (bytes32)\n    {\n        return dragos[_id].meta[_key];\n    }\n\n    /// @dev Provides the addresses of the groups/factories\n    /// @return Array of addresses of the groups\n    function getGroups()\n        external view\n        returns (address[] memory)\n    {\n        return groups;\n    }\n\n    /// @dev Provides the fee required to register a pool\n    /// @return Number of the fee in wei\n    function getFee()\n        external view\n        returns (uint256)\n    {\n        return fee;\n    }\n\n    /*\n     * INTERNAL FUNCTIONS\n     */\n    /// @dev Allows authority to register a pool for a certain group\n    /// @param _drago Address of the pool\n    /// @param _name Name of the pool\n    /// @param _symbol Symbol of the pool\n    /// @param _dragoId Id number of the pool\n    /// @param _owner Address of the pool owner\n    /// @param _group Address of the group/factory\n    function registerAs(\n        address _drago,\n        string memory _name,\n        string memory _symbol,\n        uint256 _dragoId,\n        address _owner,\n        address _group)\n        internal\n        returns (bool)\n    {\n        dragos.push(Drago(_drago, _name, _symbol, _dragoId, _owner, _group));\n        mapFromAddress[_drago] = dragos.length;\n        mapFromName[_name] = dragos.length;\n        emit Registered(_name, _symbol, dragos.length - 1, _drago, _owner, _group);\n        return true;\n    }\n\n    /// @dev Allows anyone to update the owner in the registry\n    /// @notice pool owner can change, but gets written in registry only when needed\n    /// @param _id uint256 of the target pool\n    /// @return Bollean the transaction was successful\n    function updateOwnerInternal(uint256 _id)\n        internal\n        returns (bool)\n    {\n        Drago storage pool = dragos[_id];\n        address targetPool;\n        ( targetPool, , , , , ) = fromId(_id);\n        require(getPoolOwner(targetPool) != pool.owner);\n        pool.owner = getPoolOwner(targetPool);\n        return true;\n    }\n\n    /// @dev Returns the actual owner of a pool\n    /// @notice queries from the target pool contract itself\n    /// @param pool Address of the target pool\n    /// @return Address of the pool owner\n    function getPoolOwner(address pool)\n        internal view\n        returns (address)\n    {\n        return Owned(pool).owner();\n    }\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/utils/Owned/Owned.sol": {
			"content": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract Owned {\n\n    address public owner;\n\n    event NewOwner(address indexed old, address indexed current);\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setOwner(address _new)\n        public\n        onlyOwner\n    {\n        require(_new != address(0));\n        owner = _new;\n        emit NewOwner(owner, _new);\n    }\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/protocol/DragoRegistry/DragoRegistryFace.sol": {
			"content": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.0;\n\n/// @title Drago Registry Interface - Allows external interaction with Drago Registry.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ninterface DragoRegistryFace {\n\n    //EVENTS\n\n    event Registered(string name, string symbol, uint256 id, address indexed drago, address indexed owner, address indexed group);\n    event Unregistered(string indexed name, string indexed symbol, uint256 indexed id);\n    event MetaChanged(uint256 indexed id, bytes32 indexed key, bytes32 value);\n\n    /*\n     * CORE FUNCTIONS\n     */\n    function register(address _drago, string calldata _name, string calldata _symbol, uint256 _dragoId, address _owner) external payable returns (bool);\n    function unregister(uint256 _id) external;\n    function setMeta(uint256 _id, bytes32 _key, bytes32 _value) external;\n    function addGroup(address _group) external;\n    function setFee(uint256 _fee) external;\n    function updateOwner(uint256 _id) external;\n    function updateOwners(uint256[] calldata _id) external;\n    function upgrade(address _newAddress) external payable; //payable as there is a transfer of value, otherwise opcode might throw an error\n    function setUpgraded(uint256 _version) external;\n    function drain() external;\n\n    /*\n     * CONSTANT PUBLIC FUNCTIONS\n     */\n    function dragoCount() external view returns (uint256);\n    function fromId(uint256 _id) external view returns (address drago, string memory name, string memory symbol, uint256 dragoId, address owner, address group);\n    function fromAddress(address _drago) external view returns (uint256 id, string memory name, string memory symbol, uint256 dragoId, address owner, address group);\n    function fromName(string calldata _name) external view returns (uint256 id, address drago, string memory symbol, uint256 dragoId, address owner, address group);\n    function getNameFromAddress(address _pool) external view returns (string memory);\n    function getSymbolFromAddress(address _pool) external view returns (string memory);\n    function meta(uint256 _id, bytes32 _key) external view returns (bytes32);\n    function getGroups() external view returns (address[] memory);\n    function getFee() external view returns (uint256);\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/protocol/authorities/Authority/AuthorityFace.sol": {
			"content": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity >=0.4.22 <0.6.0;\n\n/// @title Authority Interface - Allows interaction with the Authority contract.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ninterface AuthorityFace {\n\n    /*\n     * EVENTS\n     */\n    event AuthoritySet(address indexed authority);\n    event WhitelisterSet(address indexed whitelister);\n    event WhitelistedUser(address indexed target, bool approved);\n    event WhitelistedRegistry(address indexed registry, bool approved);\n    event WhitelistedFactory(address indexed factory, bool approved);\n    event WhitelistedVault(address indexed vault, bool approved);\n    event WhitelistedDrago(address indexed drago, bool isWhitelisted);\n    event NewDragoEventful(address indexed dragoEventful);\n    event NewVaultEventful(address indexed vaultEventful);\n    event NewNavVerifier(address indexed navVerifier);\n    event NewExchangesAuthority(address indexed exchangesAuthority);\n\n    /*\n     * CORE FUNCTIONS\n     */\n    function setAuthority(address _authority, bool _isWhitelisted) external;\n    function setWhitelister(address _whitelister, bool _isWhitelisted) external;\n    function whitelistUser(address _target, bool _isWhitelisted) external;\n    function whitelistDrago(address _drago, bool _isWhitelisted) external;\n    function whitelistVault(address _vault, bool _isWhitelisted) external;\n    function whitelistRegistry(address _registry, bool _isWhitelisted) external;\n    function whitelistFactory(address _factory, bool _isWhitelisted) external;\n    function setDragoEventful(address _dragoEventful) external;\n    function setVaultEventful(address _vaultEventful) external;\n    function setNavVerifier(address _navVerifier) external;\n    function setExchangesAuthority(address _exchangesAuthority) external;\n\n    /*\n     * CONSTANT PUBLIC FUNCTIONS\n     */\n    function isWhitelistedUser(address _target) external view returns (bool);\n    function isAuthority(address _authority) external view returns (bool);\n    function isWhitelistedRegistry(address _registry) external view returns (bool);\n    function isWhitelistedDrago(address _drago) external view returns (bool);\n    function isWhitelistedVault(address _vault) external view returns (bool);\n    function isWhitelistedFactory(address _factory) external view returns (bool);\n    function getDragoEventful() external view returns (address);\n    function getVaultEventful() external view returns (address);\n    function getNavVerifier() external view returns (address);\n    function getExchangesAuthority() external view returns (address);\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/utils/LibSanitize/LibSanitize.sol": {
			"content": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.0;\n\n/// @title Lib Sanitize - Sanitize strings in smart contracts.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\nlibrary LibSanitize {\n\n    function isValidCheck(string memory str)\n        internal\n        pure\n        returns (bool)\n    {\n        bytes memory bStr = bytes(str);\n        uint arrayLength = bStr.length;\n        require(\n            bStr[0] != byte(uint8(32))\n        );    \n        require(\n            bStr[arrayLength - 1] != byte(uint8(32))\n        );    \n        for (uint i =0; i < arrayLength; i++) {\n            if (\n                (\n                    bStr[i] < byte(uint8(48)) ||\n                    bStr[i] > byte(uint8(122)) ||\n                    bStr[i] > byte(uint8(57)) && bStr[i] < byte(uint8(65)) ||\n                    bStr[i] > byte(uint8(90)) && bStr[i] < byte(uint8(97))\n                ) && bStr[i] != byte(uint8(32))\n            ) return false;\n        } return true;\n    }\n\n    function isLowercase(string memory str)\n        internal\n        pure\n        returns (bool)\n    {\n        bytes memory bStr = bytes(str);\n        uint arrayLength = bStr.length;\n\t\t    for (uint i = 0; i < arrayLength; i++) {\n\t\t\t     if ((bStr[i] >= byte(uint8(65))) && (bStr[i] <= byte(uint8(90)))) return false;\n\t\t    } return true;\n    }\n\n    function isUppercase(string memory str)\n        internal\n        pure\n        returns (bool)\n    {\n        bytes memory bStr = bytes(str);\n        uint arrayLength = bStr.length;\n        for (uint i = 0; i < arrayLength; i++) {\n            if ((bStr[i] >= byte(uint8(97))) && (bStr[i] <= byte(uint8(122)))) return false;\n        } return true;\n    }\n}\n"
		}
	},
	"settings": {
		"remappings": [],
		"optimizer": {
			"enabled": true,
			"runs": 1000000
		},
		"outputSelection": {
			"*": {
				"*": [
					"abi",
					"devdoc",
					"evm.bytecode.object",
					"evm.bytecode.sourceMap",
					"evm.deployedBytecode.object",
					"evm.deployedBytecode.sourceMap"
				]
			}
		},
		"version": "0.5.0+commit.1d4f565a"
	}
}