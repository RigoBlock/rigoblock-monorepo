{
	"schemaVersion": "2.0.0",
	"contractName": "Inflation",
	"compilerOutput": {
		"abi": [
			{
				"constant": false,
				"inputs": [
					{
						"name": "groupAddress",
						"type": "address"
					},
					{
						"name": "inflationFactor",
						"type": "uint256"
					}
				],
				"name": "setInflationFactor",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"constant": false,
				"inputs": [
					{
						"name": "newPeriod",
						"type": "uint256"
					}
				],
				"name": "setPeriod",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [],
				"name": "slot",
				"outputs": [
					{
						"name": "",
						"type": "uint256"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [],
				"name": "authorityAddress",
				"outputs": [
					{
						"name": "",
						"type": "address"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [
					{
						"name": "stakingPoolId",
						"type": "bytes32"
					}
				],
				"name": "timeUntilClaim",
				"outputs": [
					{
						"name": "",
						"type": "uint256"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [
					{
						"name": "totalGrgDelegatedToPool",
						"type": "uint256"
					}
				],
				"name": "getMaxEpochReward",
				"outputs": [
					{
						"name": "",
						"type": "uint256"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [],
				"name": "STAKINGPROXYADDRESS",
				"outputs": [
					{
						"name": "",
						"type": "address"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": false,
				"inputs": [
					{
						"name": "stakingProxyAddress",
						"type": "address"
					}
				],
				"name": "setStakingProxy",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [
					{
						"name": "stakingPoolId",
						"type": "bytes32"
					}
				],
				"name": "canWithdraw",
				"outputs": [
					{
						"name": "",
						"type": "bool"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": false,
				"inputs": [
					{
						"name": "minimum",
						"type": "uint256"
					}
				],
				"name": "setMinimumRigo",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"constant": false,
				"inputs": [
					{
						"name": "newRigoblockDaoAddress",
						"type": "address"
					}
				],
				"name": "setRigoblock",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"constant": false,
				"inputs": [
					{
						"name": "newAuthorityAddress",
						"type": "address"
					}
				],
				"name": "setAuthority",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [],
				"name": "rigoblockDaoAddress",
				"outputs": [
					{
						"name": "",
						"type": "address"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": false,
				"inputs": [
					{
						"name": "stakingPoolId",
						"type": "bytes32"
					},
					{
						"name": "reward",
						"type": "uint256"
					}
				],
				"name": "mintInflation",
				"outputs": [
					{
						"name": "",
						"type": "bool"
					}
				],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"constant": false,
				"inputs": [
					{
						"name": "stakingProxyAddress",
						"type": "address"
					}
				],
				"name": "setStakingProxyAddres",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [],
				"name": "RIGOTOKENADDRESS",
				"outputs": [
					{
						"name": "",
						"type": "address"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [
					{
						"name": "groupAddress",
						"type": "address"
					}
				],
				"name": "getInflationFactor",
				"outputs": [
					{
						"name": "",
						"type": "uint256"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [],
				"name": "period",
				"outputs": [
					{
						"name": "",
						"type": "uint256"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [],
				"name": "minimumGRG",
				"outputs": [
					{
						"name": "",
						"type": "uint256"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"name": "_rigoTokenAddress",
						"type": "address"
					},
					{
						"name": "_stakingProxyAddress",
						"type": "address"
					},
					{
						"name": "_authorityAddress",
						"type": "address"
					}
				],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "constructor"
			}
		],
		"devdoc": {
			"author": "Gabriele Rigo - <gab@rigoblock.com>",
			"methods": {
				"canWithdraw(bytes32)": {
					"details": "Returns whether a staking pool's reward can be claimed.",
					"params": {
						"stakingPoolId": "Address of the target pool."
					},
					"return": "Bool the wizard can claim."
				},
				"getInflationFactor(address)": {
					"details": "Return the reward factor for a group.",
					"params": {
						"groupAddress": "Address of the group."
					},
					"return": "Value of the reward factor."
				},
				"getMaxEpochReward(uint256)": {
					"details": "Returns the max epoch reward of a pool.",
					"params": {
						"totalGrgDelegatedToPool": "Total amount of GRG delegated to the pool."
					},
					"return": "Value of the maximum pool reward."
				},
				"mintInflation(bytes32,uint256)": {
					"details": "Allows ProofOfPerformance to mint rewards.",
					"params": {
						"reward": "Number of reward in Rigo tokens.",
						"stakingPoolId": "String of the staking pool."
					},
					"return": "Bool the transaction executed correctly."
				},
				"setAuthority(address)": {
					"details": "Allows rigoblock dao to update the authority.",
					"params": {
						"newAuthorityAddress": "Address of the authority."
					}
				},
				"setInflationFactor(address,uint256)": {
					"details": "Allows rigoblock dao to set the inflation factor for a group.",
					"params": {
						"groupAddress": "Address of the group/factory.",
						"inflationFactor": "Value of the reward factor."
					}
				},
				"setMinimumRigo(uint256)": {
					"details": "Allows rigoblock dao to set the minimum number of required tokens.",
					"params": {
						"minimum": "Number of minimum tokens."
					}
				},
				"setPeriod(uint256)": {
					"details": "Allows rigoblock dao to set the minimum time between reward collection.",
					"params": {
						"newPeriod": "Number of seconds between 2 rewards."
					}
				},
				"setRigoblock(address)": {
					"details": "Allows rigoblock dao to upgrade its address.",
					"params": {
						"newRigoblockDaoAddress": "Address of the new rigoblock dao."
					}
				},
				"setStakingProxyAddres(address)": {
					"details": "Allows rigoblock dao to update staking proxy address.",
					"params": {
						"stakingProxyAddress": "Address of the staking proxy contract."
					}
				},
				"timeUntilClaim(bytes32)": {
					"details": "Returns how much time needed until next claim.",
					"params": {
						"stakingPoolId": "Address of the target pool."
					},
					"return": "Number in seconds."
				}
			},
			"title": "Inflation - Allows ProofOfPerformance to mint tokens."
		},
		"evm": {
			"bytecode": {
				"linkReferences": {},
				"object": "0x",
				"opcodes": "",
				"sourceMap": ""
			},
			"deployedBytecode": {
				"linkReferences": {},
				"object": "0x",
				"opcodes": "",
				"sourceMap": ""
			}
		}
	},
	"sourceTreeHashHex": "0xc7982b52c8ed08cb2f37fccf59e9055ec4c1a580e41ad2786a95f9cd0d90127c",
	"sources": {
		"./Inflation.sol": {
			"id": 2
		},
		"../../utils/Owned/Owned.sol": {
			"id": 7
		},
		"../../protocol/authorities/Authority/AuthorityFace.sol": {
			"id": 1
		},
		"../../utils/SafeMath/SafeMath.sol": {
			"id": 10
		},
		"./InflationFace.sol": {
			"id": 3
		},
		"../RigoToken/RigoTokenFace.sol": {
			"id": 6
		}
	},
	"sourceCodes": {
		"./Inflation.sol": "/*\n\n Copyright 2017-2019 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.4;\npragma experimental ABIEncoderV2;\n\nimport { Owned } from \"../../utils/Owned/Owned.sol\";\nimport { AuthorityFace as Authority } from \"../../protocol/authorities/Authority/AuthorityFace.sol\";\nimport { SafeMath } from \"../../utils/SafeMath/SafeMath.sol\";\nimport { InflationFace } from \"./InflationFace.sol\";\nimport { RigoTokenFace } from \"../RigoToken/RigoTokenFace.sol\";\n\n\ninterface IStructs {\n    /// @dev Encapsulates a balance for the current and next epochs.\n    /// Note that these balances may be stale if the current epoch\n    /// is greater than `currentEpoch`.\n    /// @param currentEpoch The current epoch\n    /// @param currentEpochBalance Balance in the current epoch.\n    /// @param nextEpochBalance Balance in `currentEpoch+1`.\n    struct StoredBalance {\n        uint64 currentEpoch;\n        uint96 currentEpochBalance;\n        uint96 nextEpochBalance;\n    }\n}\n\ninterface Staking {\n\n    /// @dev Returns the total stake delegated to a specific staking pool,\n    ///      across all members.\n    /// @param poolId Unique Id of pool.\n    /// @return balance Total stake delegated to pool.\n    function getTotalStakeDelegatedToPool(bytes32 poolId)\n        external\n        view\n        returns (IStructs.StoredBalance memory balance);\n}\n\n/// @title Inflation - Allows ProofOfPerformance to mint tokens.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ncontract Inflation is\n    SafeMath,\n    InflationFace\n{\n    address public RIGOTOKENADDRESS;\n    address public STAKINGPROXYADDRESS;\n\n    uint256 public period = 14 days;\n    uint256 public minimumGRG = 100 * 10**18;\n    uint256 public slot;\n    address public authorityAddress;\n    address public rigoblockDaoAddress;\n\n    mapping(bytes32 => Performer) performers;\n    mapping(address => Group) groups;\n\n    struct Performer {\n        uint256 claimedTokens;\n        mapping(uint256 => bool) claim;\n        uint256 startTime;\n        uint256 endTime;\n    }\n\n    struct Group {\n        uint256 epochReward;\n    }\n\n    modifier onlyRigoblockDao {\n        _assertCallerIsRigoblockDao();\n        _;\n    }\n\n    modifier onlyStakingProxy {\n        _assertCallerIsStakingProxy();\n        _;\n    }\n\n    modifier isApprovedFactory(address _factory) {\n        _assertIsApprovedFactory(_factory);\n        _;\n    }\n\n    modifier timeAtLeast(bytes32 stakingPoolId) {\n        _assertTimeAtLeast(stakingPoolId);\n        _;\n    }\n\n    constructor(\n        address _rigoTokenAddress,\n        address _stakingProxyAddress,\n        address _authorityAddress\n    )\n        public\n    {\n        RIGOTOKENADDRESS = _rigoTokenAddress;\n        STAKINGPROXYADDRESS = _stakingProxyAddress;\n        rigoblockDaoAddress = msg.sender;\n        authorityAddress = _authorityAddress;\n    }\n\n    /*\n     * CORE FUNCTIONS\n     */\n    /// @dev Allows ProofOfPerformance to mint rewards.\n    /// @param stakingPoolId String of the staking pool.\n    /// @param reward Number of reward in Rigo tokens.\n    /// @return Bool the transaction executed correctly.\n    function mintInflation(bytes32 stakingPoolId, uint256 reward)\n        external\n        onlyStakingProxy\n        timeAtLeast(stakingPoolId)\n        returns (bool)\n    {\n        //TODO: test\n        uint256 totalGrgDelegatedToPool = _getTotalGrgDelegatedToPool(stakingPoolId);\n        \n        _assertMinimumGrgContraintSatisfied(totalGrgDelegatedToPool);\n        _assertRewardNotAboveMaxEpochReward(reward, totalGrgDelegatedToPool);\n\n        performers[stakingPoolId].startTime = block.timestamp;\n        performers[stakingPoolId].endTime = block.timestamp + period;\n        ++slot;\n        uint256 rigoblockDaoReward = reward * 5 / 100; //5% royalty to rigoblock dao\n        RigoTokenFace rigoToken = RigoTokenFace(RIGOTOKENADDRESS);\n        // TODO: test\n        rigoToken.mintToken(rigoblockDaoAddress, rigoblockDaoReward);\n        rigoToken.mintToken(\n            STAKINGPROXYADDRESS,\n            reward\n        );\n        return true;\n    }\n\n    /// @dev Allows rigoblock dao to set the inflation factor for a group.\n    /// @param groupAddress Address of the group/factory.\n    /// @param inflationFactor Value of the reward factor.\n    function setInflationFactor(address groupAddress, uint256 inflationFactor)\n        external\n        onlyRigoblockDao\n        isApprovedFactory(groupAddress)\n    {\n        groups[groupAddress].epochReward = inflationFactor;\n    }\n\n    /// @dev Allows rigoblock dao to set the minimum number of required tokens.\n    /// @param minimum Number of minimum tokens.\n    function setMinimumRigo(uint256 minimum)\n        external\n        onlyRigoblockDao\n    {\n        require(\n            minimum >= 100 * 10**18,\n            \"MINIMUM_GRG_BELOW_100_ERROR\"\n        );\n        minimumGRG = minimum;\n    }\n\n    /// @dev Allows rigoblock dao to upgrade its address.\n    /// @param newRigoblockDaoAddress Address of the new rigoblock dao.\n    function setRigoblock(address newRigoblockDaoAddress)\n        external\n        onlyRigoblockDao\n    {\n        rigoblockDaoAddress = newRigoblockDaoAddress;\n    }\n\n    /// @dev Allows rigoblock dao to update the authority.\n    /// @param newAuthorityAddress Address of the authority.\n    function setAuthority(address newAuthorityAddress)\n        external\n        onlyRigoblockDao\n    {\n        authorityAddress = newAuthorityAddress;\n    }\n\n    /// @dev Allows rigoblock dao to update staking proxy address.\n    /// @param stakingProxyAddress Address of the staking proxy contract.\n    function setStakingProxyAddres(address stakingProxyAddress)\n        external\n        onlyRigoblockDao\n    {\n        STAKINGPROXYADDRESS = stakingProxyAddress;\n    }\n\n    /// @dev Allows rigoblock dao to set the minimum time between reward collection.\n    /// @param newPeriod Number of seconds between 2 rewards.\n    /// @notice set period on shorter subsets of time for testing.\n    function setPeriod(uint256 newPeriod)\n        external\n        onlyRigoblockDao\n    {\n        require(\n            newPeriod >= 1 days && newPeriod <= 365 days,\n            \"PERIOD_TOO_LONG_OR_TOO_SHORT_ERROR\"\n        );\n        period = newPeriod;\n    }\n\n    /*\n     * CONSTANT PUBLIC FUNCTIONS\n     */\n    /// @dev Returns whether a staking pool's reward can be claimed.\n    /// @param stakingPoolId Address of the target pool.\n    /// @return Bool the wizard can claim.\n    function canWithdraw(bytes32 stakingPoolId)\n        external\n        view\n        returns (bool)\n    {\n        if (block.timestamp >= performers[stakingPoolId].endTime) {\n            return true;\n        }\n    }\n\n    /// @dev Returns how much time needed until next claim.\n    /// @param stakingPoolId Address of the target pool.\n    /// @return Number in seconds.\n    function timeUntilClaim(bytes32 stakingPoolId)\n        external\n        view\n        returns (uint256)\n    {\n        if (block.timestamp < performers[stakingPoolId].endTime) {\n            return (performers[stakingPoolId].endTime - block.timestamp);\n        } else return (uint256(0));\n    }\n\n    /// @dev Return the reward factor for a group.\n    /// @param groupAddress Address of the group.\n    /// @return Value of the reward factor.\n    function getInflationFactor(address groupAddress)\n        external\n        view\n        returns (uint256)\n    {\n        return groups[groupAddress].epochReward;\n    }\n    \n    /// @dev Returns the max epoch reward of a pool.\n    /// @param totalGrgDelegatedToPool Total amount of GRG delegated to the pool.\n    /// @return Value of the maximum pool reward.\n    function getMaxEpochReward(uint256 totalGrgDelegatedToPool) public view returns (uint256) {\n        return safeDiv(\n            totalGrgDelegatedToPool * period,\n            _getDisinflationaryDivisor() * 365 days // multiply in order not to dividing in previous line\n        );\n    }\n    \n    /*\n     * INTERNAL METHODS\n     */\n    /// @dev Returns the amount of GRG staked to a pool.\n    /// @param stakingPoolId ID of the staking pool.\n    /// @return Amount of GRG staked.\n    function _getTotalGrgDelegatedToPool(bytes32 stakingPoolId) internal view returns (uint256) {\n        return uint256(\n            Staking(STAKINGPROXYADDRESS)\n            .getTotalStakeDelegatedToPool(stakingPoolId)\n            .currentEpochBalance\n        );\n    }\n    \n    /// @dev Asserts that the minimum GRG amount is staked.\n    /// @param totalGrgDelegatedToPool GRG amount staked to pool.\n    function _assertMinimumGrgContraintSatisfied(uint256 totalGrgDelegatedToPool)\n        internal\n        view\n    {\n        if (totalGrgDelegatedToPool < minimumGRG) {\n            revert(\"STAKED_GRG_AMOUNT_BELOW_MINIMUM_ERROR\");\n        }\n    }\n    \n    /// @dev Asserts that the caller is the RigoBlock Dao.\n    function _assertCallerIsRigoblockDao()\n        internal\n        view\n    {\n        if (msg.sender != rigoblockDaoAddress) {\n            revert(\"CALLER_NOT_RIGOBLOCK_DAO_ERROR\");\n        }\n    }\n    \n    /// @dev Asserts that the caller is the Staking Proxy.\n    function _assertCallerIsStakingProxy()\n        internal\n        view\n    {\n        if (msg.sender != STAKINGPROXYADDRESS) {\n            revert(\"CALLER_NOT_STAKING_PROXY_ERROR\");\n        }\n    }\n    \n    /// @dev Asserts that an address is an approved factory.\n    /// @param _factory Address of the target factory.\n    function _assertIsApprovedFactory(address _factory)\n        internal\n        view\n    {\n        if (!Authority(authorityAddress).isWhitelistedFactory(_factory)) \n        {\n            revert(\"NOT_APPROVED_AUTHORITY_ERROR\");\n        }\n    }\n    \n    /// @dev Asserts that the minimum time has past.\n    /// @param stakingPoolId Hex-encoded staking pool id.\n    function _assertTimeAtLeast(bytes32 stakingPoolId)\n        internal\n        view\n    {\n        if (block.timestamp < performers[stakingPoolId].endTime) {\n            revert(\"TIME_NOT_ENOUGH_ERROR\");\n        }\n    }\n    \n    /// @dev Asserts that the reward is below the maximum allowed.\n    /// @param reward Reward to be sent.\n    /// @param totalGrgDelegatedToPool GRG amount staked to pool.\n    function _assertRewardNotAboveMaxEpochReward(\n        uint256 reward,\n        uint256 totalGrgDelegatedToPool\n    )\n        internal\n        view\n    {\n        if (reward > getMaxEpochReward(totalGrgDelegatedToPool)) {\n            revert(\"REWARD_ABOVE_MAX_EPOCH_REWARD_ERROR\");\n        }\n    }\n    \n    /// @dev Returns the value of the disinflationary divisor.\n    /// @return Value of the divisor.\n    function _getDisinflationaryDivisor() internal view returns (uint256) {\n        uint256 firstHalving = uint256(1639130400); // 10 Dec 2021 10:00pm UTC\n        if (block.timestamp < firstHalving) {\n            return uint256(1);\n        } else if (block.timestamp < firstHalving + 52 weeks) {\n            return uint256(2);\n        } else return uint256(4);\n    }\n}\n",
		"../../utils/Owned/Owned.sol": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract Owned {\n\n    address public owner;\n\n    event NewOwner(address indexed old, address indexed current);\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setOwner(address _new)\n        public\n        onlyOwner\n    {\n        require(_new != address(0));\n        owner = _new;\n        emit NewOwner(owner, _new);\n    }\n}\n",
		"../../protocol/authorities/Authority/AuthorityFace.sol": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity >=0.4.22 <0.6.0;\n\n/// @title Authority Interface - Allows interaction with the Authority contract.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ninterface AuthorityFace {\n\n    /*\n     * EVENTS\n     */\n    event AuthoritySet(address indexed authority);\n    event WhitelisterSet(address indexed whitelister);\n    event WhitelistedUser(address indexed target, bool approved);\n    event WhitelistedRegistry(address indexed registry, bool approved);\n    event WhitelistedFactory(address indexed factory, bool approved);\n    event WhitelistedVault(address indexed vault, bool approved);\n    event WhitelistedDrago(address indexed drago, bool isWhitelisted);\n    event NewDragoEventful(address indexed dragoEventful);\n    event NewVaultEventful(address indexed vaultEventful);\n    event NewNavVerifier(address indexed navVerifier);\n    event NewExchangesAuthority(address indexed exchangesAuthority);\n\n    /*\n     * CORE FUNCTIONS\n     */\n    function setAuthority(address _authority, bool _isWhitelisted) external;\n    function setWhitelister(address _whitelister, bool _isWhitelisted) external;\n    function whitelistUser(address _target, bool _isWhitelisted) external;\n    function whitelistDrago(address _drago, bool _isWhitelisted) external;\n    function whitelistVault(address _vault, bool _isWhitelisted) external;\n    function whitelistRegistry(address _registry, bool _isWhitelisted) external;\n    function whitelistFactory(address _factory, bool _isWhitelisted) external;\n    function setDragoEventful(address _dragoEventful) external;\n    function setVaultEventful(address _vaultEventful) external;\n    function setNavVerifier(address _navVerifier) external;\n    function setExchangesAuthority(address _exchangesAuthority) external;\n\n    /*\n     * CONSTANT PUBLIC FUNCTIONS\n     */\n    function isWhitelistedUser(address _target) external view returns (bool);\n    function isAuthority(address _authority) external view returns (bool);\n    function isWhitelistedRegistry(address _registry) external view returns (bool);\n    function isWhitelistedDrago(address _drago) external view returns (bool);\n    function isWhitelistedVault(address _vault) external view returns (bool);\n    function isWhitelistedFactory(address _factory) external view returns (bool);\n    function getDragoEventful() external view returns (address);\n    function getVaultEventful() external view returns (address);\n    function getNavVerifier() external view returns (address);\n    function getExchangesAuthority() external view returns (address);\n}\n",
		"../../utils/SafeMath/SafeMath.sol": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract SafeMath {\n\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b > 0);\n        uint256 c = a / b;\n        assert(a == b * c + a % b);\n        return c;\n    }\n\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c>=a && c>=b);\n        return c;\n    }\n\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a >= b ? a : b;\n    }\n\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a < b ? a : b;\n    }\n\n    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n",
		"./InflationFace.sol": "/*\n\n Copyright 2017-2019 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity >=0.4.22 <0.8.0;\n\n/// @title Inflation Interface - Allows interaction with the Inflation contract.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ninterface InflationFace {\n\n    function period() external view returns (uint256);\n\n    /*\n     * CORE FUNCTIONS\n     */\n    function mintInflation(bytes32 stakingPoolId, uint256 reward) external returns (bool);\n    function setInflationFactor(address groupAddress, uint256 inflationFactor) external;\n    function setMinimumRigo(uint256 minimum) external;\n    function setRigoblock(address newRigoblockDaoAddress) external;\n    function setAuthority(address newRigoblockDaoAddress) external;\n    function setStakingProxy(address stakingProxyAddress) external;\n    function setPeriod(uint256 newPeriod) external;\n\n    /*\n     * CONSTANT PUBLIC FUNCTIONS\n     */\n    function canWithdraw(bytes32 stakingPoolId) external view returns (bool);\n    function timeUntilClaim(bytes32 stakingPoolId) external view returns (uint256);\n    function getInflationFactor(address groupAddress) external view returns (uint256);\n    function getMaxEpochReward(uint256 totalGrgDelegatedToPool) external view returns (uint256);\n}\n",
		"../RigoToken/RigoTokenFace.sol": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity >=0.5.0;\n\n/// @title Rigo Token Interface - Allows interaction with the Rigo token.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ninterface RigoTokenFace {\n\n    function minter() external view returns (address);\n\n    /// @dev send `value` token to `to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return True if transfer was successful\n    function transfer(address _to, uint256 _value)\n        external\n        returns (bool);\n\n    /// @dev send `value` token to `to` from `from` on the condition it is approved by `from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return True if transfer was successful\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        external\n        returns (bool);\n\n    /// @dev `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return Always true if the call has enough gas to complete execution\n    function approve(address _spender, uint256 _value)\n        external\n        returns (bool);\n\n    /// @dev Query total supply of token\n    /// @return Total supply of token\n    function totalSupply()\n        external\n        view\n        returns (uint256);\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return Balance of owner\n    function balanceOf(address _owner)\n        external\n        view\n        returns (uint256);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender)\n        external\n        view\n        returns (uint256);\n\n    function mintToken(address _recipient, uint256 _amount) external;\n    function changeMintingAddress(address _newAddress) external;\n    function changeRigoblockAddress(address _newAddress) external;\n}\n"
	},
	"compiler": {
		"name": "solc",
		"version": "0.5.4+commit.9549d8ff",
		"settings": {
			"remappings": [],
			"optimizer": {
				"enabled": true,
				"runs": 1000000
			},
			"outputSelection": {
				"*": {
					"*": [
						"abi",
						"devdoc",
						"evm.bytecode.object",
						"evm.bytecode.sourceMap",
						"evm.deployedBytecode.object",
						"evm.deployedBytecode.sourceMap"
					]
				}
			}
		}
	},
	"chains": {}
}