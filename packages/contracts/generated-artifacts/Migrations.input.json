{
	"language": "Solidity",
	"sources": {
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/Migrations.sol": {
			"content": "pragma solidity 0.4.25;\n\ncontract Migrations {\n    address public owner;\n    uint256 public last_completed_migration;\n\n    modifier restricted() {\n        if (msg.sender == owner)\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setCompleted(uint256 completed) public restricted {\n        last_completed_migration = completed;\n    }\n\n    function upgrade(address new_address) public restricted {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/protocol/extensions/adapters/ASelfCustody.sol": {
			"content": "/*\n\n Copyright 2019 RigoBlock, Gabriele Rigo.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.4.25;\n\ncontract SafeMath {\n\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b > 0);\n        uint256 c = a / b;\n        assert(a == b * c + a % b);\n        return c;\n    }\n}\n\n\ninterface Token {\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    function balanceOf(address _who) external view returns (uint256);\n}\n\ninterface DragoEventful {\n\n    function customDragoLog(bytes4 _methodHash, bytes _encodedParams) external returns (bool success);\n}\n\ninterface ExchangesAuthority {\n\n    function getCasper() external view returns (address);\n}\n\ncontract Drago {\n\n    address public owner;\n\n    function getExchangesAuth() external view returns (address);\n\n    function getEventful() external view returns (address);\n}\n\n/// @title Self Custody adapter - A helper contract for self custody.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ncontract ASelfCustody is SafeMath {\n\n    /// @dev transfers ETH or tokens to self custody.\n    /// @param selfCustodyAccount Address of the target account.\n    /// @param token Address of the target token.\n    /// @param amount Number of tokens.\n    /// @return Bool the transaction was successful.\n    /// @return Number of GRG pool operator shortfall.\n    /// @notice Transfeer of tokens excluded from GRG requirement for now.\n    function transferToSelfCustody(\n        address selfCustodyAccount,\n        address token,\n        uint256 amount)\n        external\n        returns (bool, uint256)\n    {\n        require(\n            Drago(\n                address(this)\n            ).owner() == msg.sender,\n            \"FAIL_OWNER_CHECK\"\n        );\n        address grgToken =\n            ExchangesAuthority(\n                Drago(\n                    address(this)\n                ).getExchangesAuth()\n            ).getCasper()\n        ;\n        require(amount != uint256(0));\n        (bool satisfied, uint256 shortfall) = operatorGRGminimumSatisfied(grgToken, token, amount);\n        if (satisfied == true) {\n            require(\n                transferToSelfCustodyInternal(selfCustodyAccount, token, amount),\n                \"TRANSFER_FAIL_GRG_REQ_SATISFIED_ERROR\"\n                );\n            require(\n                logTransferToSelfCustody(selfCustodyAccount, token, amount),\n                \"LOG_FAIL_GRG_REQ_SATISFIED_ERROR\"\n                );\n            return (true, shortfall);\n        } else {\n            return (false, shortfall);\n        }\n    }\n\n    /// @dev external check if minimum pool operator GRG amount requirement satisfied.\n    /// @param grgToken Address of the Rigo token.\n    /// @param token Address of the token to be transferred.\n    /// @param amount Number of tokens to be transferred.\n    /// @return Bool the transaction was successful.\n    /// @return Number of GRG pool operator shortfall.\n    /// @notice built around powers of pi number.\n    function operatorGRGminimumSatisfiedExternal (address grgToken, address token, uint256 amount)\n        external\n        view\n        returns (bool satisfied, uint256 shortfall)\n    {\n        return operatorGRGminimumSatisfied(grgToken, token, amount);\n    }\n\n    /*\n     * INTERNAL FUNCTIONS\n     */\n    /// @dev checks if minimum pool operator GRG amount requirement satisfied.\n    /// @param grgToken Address of the Rigo token.\n    /// @param token Address of the token to be transferred.\n    /// @param amount Number of tokens to be transferred.\n    /// @return Bool the transaction was successful.\n    /// @return Number of GRG pool operator shortfall.\n    /// @notice built around powers of pi number.\n    function operatorGRGminimumSatisfied(address grgToken, address token, uint256 amount)\n        internal\n        view\n        returns (bool satisfied, uint256 shortfall)\n    {\n        uint256 ether_base = 18;\n        uint256 rational_base = 36;\n        uint256 rationalized_amount_base36 = safeMul(amount, 10 ** (rational_base - ether_base));\n        uint256 operator_rationalized_GRG_balance_base36 = Token(grgToken).balanceOf(msg.sender) * (10 ** (rational_base - ether_base));\n\n        if (token != address(0)) {\n            satisfied = true;\n            shortfall = uint256(0);\n\n        } else if (rationalized_amount_base36 < findPi()) {\n            satisfied = true;\n            shortfall = uint256(0);\n\n        } else if (rationalized_amount_base36 < findPi2()) {\n            if (operator_rationalized_GRG_balance_base36 < findPi4()) {\n                satisfied = false;\n                shortfall = safeDiv(findPi4() - operator_rationalized_GRG_balance_base36, (10 ** (rational_base - ether_base)));\n            } else {\n                satisfied = true;\n                shortfall = uint256(0);\n            }\n\n        } else if (rationalized_amount_base36 < findPi3()) {\n            if (operator_rationalized_GRG_balance_base36 < findPi5()) {\n                satisfied = false;\n                shortfall = safeDiv(findPi5() - operator_rationalized_GRG_balance_base36, (10 ** (rational_base - ether_base)));\n            } else {\n                satisfied = true;\n                shortfall = uint256(0);\n            }\n\n        } else if (rationalized_amount_base36 >= findPi3()) {\n            if (operator_rationalized_GRG_balance_base36 < findPi6()) {\n                satisfied = false;\n                shortfall = safeDiv(findPi6() - operator_rationalized_GRG_balance_base36, (10 ** (rational_base - ether_base)));\n            } else {\n                satisfied = true;\n                shortfall = uint256(0);\n            }\n\n        } else {\n            revert(\"UNKNOWN_GRG_MINIMUM_ERROR\");\n        }\n\n        return (satisfied, shortfall);\n    }\n\n    /// @dev returns the base 36 value of pi number.\n    /// @return pi1 Value of pi.\n    function findPi() internal pure returns (uint256 pi1) {\n        uint8 power = 1;\n        uint256 pi = 3141592;\n        uint256 pi_base = 6;\n        uint256 rational_base = 36;\n        pi1 = pi ** power * 10 ** (rational_base - pi_base * power);\n    }\n\n    /// @dev returns the base 36 value of pi^2 number.\n    /// @return pi2 Value of pi^2.\n    function findPi2() internal pure returns (uint256 pi2) {\n        uint8 power = 2;\n        uint256 pi = 3141592;\n        uint256 pi_base = 6;\n        uint256 rational_base = 36;\n        pi2 = pi ** power * 10 ** (rational_base - pi_base * power);\n    }\n\n    /// @dev returns the base 36 value of pi^3 number.\n    /// @return pi3 Value of pi^3.\n    function findPi3() internal pure returns (uint256 pi3) {\n        uint8 power = 3;\n        uint256 pi = 3141592;\n        uint256 pi_base = 6;\n        uint256 rational_base = 36;\n        pi3 = pi ** power * 10 ** (rational_base - pi_base * power);\n    }\n\n    /// @dev returns the base 36 value of pi^4 number.\n    /// @return pi4 Value of pi^4.\n    function findPi4() internal pure returns (uint256 pi4) {\n        uint8 power = 4;\n        uint256 pi = 3141592;\n        uint256 pi_base = 6;\n        uint256 rational_base = 36;\n        pi4 = pi ** power * 10 ** (rational_base - pi_base * power);\n    }\n\n    /// @dev returns the base 36 value of pi^5 number.\n    /// @return pi5 Value of pi^5.\n    function findPi5() internal pure returns (uint256 pi5) {\n        uint8 power = 5;\n        uint256 pi = 3141592;\n        uint256 pi_base = 6;\n        uint256 rational_base = 36;\n        pi5 = pi ** power * 10 ** (rational_base - pi_base * power);\n    }\n\n    /// @dev returns the base 36 value of pi^6 number.\n    /// @return pi6 Value of pi^6.\n    function findPi6() internal pure returns (uint256 pi6) {\n        uint8 power = 6;\n        uint256 pi = 3141592;\n        uint256 pi_base = 6;\n        uint256 rational_base = 36;\n        pi6 = pi ** power * 10 ** (rational_base - pi_base * power);\n    }\n\n    /// @dev prints a custom log of the transfer.\n    /// @param selfCustodyAccount Address of the self custody account.\n    /// @param token Address of the token transferred.\n    /// @param amount Number of tokens.\n    /// @return Bool the log is printed correctly.\n    function logTransferToSelfCustody(\n        address selfCustodyAccount,\n        address token,\n        uint256 amount)\n        internal\n        returns (bool)\n    {\n        DragoEventful events = DragoEventful(getDragoEventful());\n        bytes4 methodHash = bytes4(keccak256(\"transferToSelfCustody(address,address,uint256)\"));\n        bytes memory encodedParams = abi.encode(\n            address(this),\n            selfCustodyAccount,\n            token,\n            amount\n            );\n        require(\n            events.customDragoLog(methodHash, encodedParams),\n            \"ISSUE_IN_EVENTFUL\"\n            );\n        return true;\n    }\n\n    /// @dev executes the ETH or token transfer.\n    /// @param selfCustodyAccount Address of the self custody account.\n    /// @param token Address of the target token.\n    /// @param amount Number of tokens to be transferred.\n    /// @return success Bool the transfer executed correctly.\n    function transferToSelfCustodyInternal(\n        address selfCustodyAccount,\n        address token,\n        uint256 amount)\n        internal\n        returns (bool success)\n    {\n        if (token == address(0)) {\n            selfCustodyAccount.transfer(amount);\n            success = true;\n        } else {\n            Token(token).transfer(selfCustodyAccount, amount);\n            success = true;\n        }\n        return success;\n    }\n\n    /// @dev Gets the address of the logger contract.\n    /// @return Address of the logger contrac.\n    function getDragoEventful()\n        internal\n        view\n        returns (address)\n    {\n        address dragoEvenfulAddress =\n            Drago(\n                address(this)\n            ).getEventful();\n        return dragoEvenfulAddress;\n    }\n}\n"
		}
	},
	"settings": {
		"remappings": [],
		"optimizer": {
			"enabled": true,
			"runs": 200
		},
		"outputSelection": {
			"*": {
				"*": [
					"abi",
					"devdoc",
					"evm.bytecode.object",
					"evm.bytecode.sourceMap",
					"evm.deployedBytecode.object",
					"evm.deployedBytecode.sourceMap"
				]
			}
		},
		"version": "0.4.25+commit.59dbf8f1"
	}
}