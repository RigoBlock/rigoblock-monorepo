{
	"schemaVersion": "2.0.0",
	"contractName": "Distribution",
	"compilerOutput": {
		"abi": [
			{
				"constant": false,
				"inputs": [
					{
						"name": "_fee",
						"type": "uint256"
					},
					{
						"name": "_distributor",
						"type": "address"
					}
				],
				"name": "setFee",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [
					{
						"name": "_distributor",
						"type": "address"
					}
				],
				"name": "getFee",
				"outputs": [
					{
						"name": "",
						"type": "uint256"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": false,
				"inputs": [
					{
						"name": "_pool",
						"type": "address"
					},
					{
						"name": "_distributor",
						"type": "address"
					},
					{
						"name": "_buyer",
						"type": "address"
					}
				],
				"name": "subscribe",
				"outputs": [],
				"payable": true,
				"stateMutability": "payable",
				"type": "function"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"name": "buyer",
						"type": "address"
					},
					{
						"indexed": true,
						"name": "distributor",
						"type": "address"
					},
					{
						"indexed": false,
						"name": "amount",
						"type": "uint256"
					}
				],
				"name": "Subscription",
				"type": "event"
			}
		],
		"devdoc": {
			"author": "Gabriele Rigo - <gab@rigoblock.com>",
			"methods": {},
			"title": "Distribution - Allows to collect subscription fees on vaults."
		},
		"evm": {
			"bytecode": {
				"linkReferences": {},
				"object": "0x608060405234801561001057600080fd5b506103c4806100206000396000f3fe6080604052600436106100565763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663b4f2e8b8811461005b578063b88c914814610096578063e487721a146100db575b600080fd5b34801561006757600080fd5b506100946004803603604081101561007e57600080fd5b5080359060200135600160a060020a0316610113565b005b3480156100a257600080fd5b506100c9600480360360208110156100b957600080fd5b5035600160a060020a031661016a565b60408051918252519081900360200190f35b610094600480360360608110156100f157600080fd5b50600160a060020a038135811691602081013582169160409091013516610185565b600160a060020a03811660009081526020819052604090205481901561013857600080fd5b81600160a060020a038116151561014e57600080fd5b5050600160a060020a0316600090815260208190526040902055565b600160a060020a031660009081526020819052604090205490565b82600160a060020a031663af41cec0826040518263ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018082600160a060020a0316600160a060020a03168152602001915050602060405180830381600087803b1580156101f957600080fd5b505af115801561020d573d6000803e3d6000fd5b505050506040513d602081101561022357600080fd5b5050600160a060020a0382166000908152602081905260408120546102559061024d903490610326565b612710610351565b905060006102633483610386565b604051909150600160a060020a0386169082156108fc029083906000818181858888f1935050505015801561029c573d6000803e3d6000fd5b50604051600160a060020a0385169083156108fc029084906000818181858888f193505050501580156102d3573d6000803e3d6000fd5b5083600160a060020a031683600160a060020a03167f4d1db39debc799df6a6a3bad1c8809c46cbe6eb3b784df03f50a061c487994c6836040518082815260200191505060405180910390a35050505050565b6000828202831580610342575082848281151561033f57fe5b04145b151561034a57fe5b9392505050565b600080821161035c57fe5b6000828481151561036957fe5b049050828481151561037757fe5b06818402018414151561034a57fe5b60008282111561039257fe5b5090039056fea165627a7a723058205ee9a6dafa856c3b9397d9034e45de70a0b2529b86e2c1068be56515ce97d60d0029",
				"opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0x3C4 DUP1 PUSH2 0x20 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH2 0x56 JUMPI PUSH4 0xFFFFFFFF PUSH29 0x100000000000000000000000000000000000000000000000000000000 PUSH1 0x0 CALLDATALOAD DIV AND PUSH4 0xB4F2E8B8 DUP2 EQ PUSH2 0x5B JUMPI DUP1 PUSH4 0xB88C9148 EQ PUSH2 0x96 JUMPI DUP1 PUSH4 0xE487721A EQ PUSH2 0xDB JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0x67 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0x94 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0x7E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD CALLDATALOAD PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB AND PUSH2 0x113 JUMP JUMPDEST STOP JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0xA2 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0xC9 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x20 DUP2 LT ISZERO PUSH2 0xB9 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP CALLDATALOAD PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB AND PUSH2 0x16A JUMP JUMPDEST PUSH1 0x40 DUP1 MLOAD SWAP2 DUP3 MSTORE MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x20 ADD SWAP1 RETURN JUMPDEST PUSH2 0x94 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x60 DUP2 LT ISZERO PUSH2 0xF1 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB DUP2 CALLDATALOAD DUP2 AND SWAP2 PUSH1 0x20 DUP2 ADD CALLDATALOAD DUP3 AND SWAP2 PUSH1 0x40 SWAP1 SWAP2 ADD CALLDATALOAD AND PUSH2 0x185 JUMP JUMPDEST PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB DUP2 AND PUSH1 0x0 SWAP1 DUP2 MSTORE PUSH1 0x20 DUP2 SWAP1 MSTORE PUSH1 0x40 SWAP1 KECCAK256 SLOAD DUP2 SWAP1 ISZERO PUSH2 0x138 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB DUP2 AND ISZERO ISZERO PUSH2 0x14E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP POP PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB AND PUSH1 0x0 SWAP1 DUP2 MSTORE PUSH1 0x20 DUP2 SWAP1 MSTORE PUSH1 0x40 SWAP1 KECCAK256 SSTORE JUMP JUMPDEST PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB AND PUSH1 0x0 SWAP1 DUP2 MSTORE PUSH1 0x20 DUP2 SWAP1 MSTORE PUSH1 0x40 SWAP1 KECCAK256 SLOAD SWAP1 JUMP JUMPDEST DUP3 PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB AND PUSH4 0xAF41CEC0 DUP3 PUSH1 0x40 MLOAD DUP3 PUSH4 0xFFFFFFFF AND PUSH29 0x100000000000000000000000000000000000000000000000000000000 MUL DUP2 MSTORE PUSH1 0x4 ADD DUP1 DUP3 PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB AND PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x1F9 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x20D JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x223 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP POP PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB DUP3 AND PUSH1 0x0 SWAP1 DUP2 MSTORE PUSH1 0x20 DUP2 SWAP1 MSTORE PUSH1 0x40 DUP2 KECCAK256 SLOAD PUSH2 0x255 SWAP1 PUSH2 0x24D SWAP1 CALLVALUE SWAP1 PUSH2 0x326 JUMP JUMPDEST PUSH2 0x2710 PUSH2 0x351 JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0x263 CALLVALUE DUP4 PUSH2 0x386 JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 SWAP2 POP PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB DUP7 AND SWAP1 DUP3 ISZERO PUSH2 0x8FC MUL SWAP1 DUP4 SWAP1 PUSH1 0x0 DUP2 DUP2 DUP2 DUP6 DUP9 DUP9 CALL SWAP4 POP POP POP POP ISZERO DUP1 ISZERO PUSH2 0x29C JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB DUP6 AND SWAP1 DUP4 ISZERO PUSH2 0x8FC MUL SWAP1 DUP5 SWAP1 PUSH1 0x0 DUP2 DUP2 DUP2 DUP6 DUP9 DUP9 CALL SWAP4 POP POP POP POP ISZERO DUP1 ISZERO PUSH2 0x2D3 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP DUP4 PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB AND DUP4 PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB AND PUSH32 0x4D1DB39DEBC799DF6A6A3BAD1C8809C46CBE6EB3B784DF03F50A061C487994C6 DUP4 PUSH1 0x40 MLOAD DUP1 DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 LOG3 POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP3 DUP3 MUL DUP4 ISZERO DUP1 PUSH2 0x342 JUMPI POP DUP3 DUP5 DUP3 DUP2 ISZERO ISZERO PUSH2 0x33F JUMPI INVALID JUMPDEST DIV EQ JUMPDEST ISZERO ISZERO PUSH2 0x34A JUMPI INVALID JUMPDEST SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 DUP3 GT PUSH2 0x35C JUMPI INVALID JUMPDEST PUSH1 0x0 DUP3 DUP5 DUP2 ISZERO ISZERO PUSH2 0x369 JUMPI INVALID JUMPDEST DIV SWAP1 POP DUP3 DUP5 DUP2 ISZERO ISZERO PUSH2 0x377 JUMPI INVALID JUMPDEST MOD DUP2 DUP5 MUL ADD DUP5 EQ ISZERO ISZERO PUSH2 0x34A JUMPI INVALID JUMPDEST PUSH1 0x0 DUP3 DUP3 GT ISZERO PUSH2 0x392 JUMPI INVALID JUMPDEST POP SWAP1 SUB SWAP1 JUMP INVALID LOG1 PUSH6 0x627A7A723058 KECCAK256 0x5e 0xe9 0xa6 0xda STATICCALL DUP6 PUSH13 0x3B9397D9034E45DE70A0B2529B DUP7 0xe2 0xc1 MOD DUP12 0xe5 PUSH6 0x15CE97D60D00 0x29 ",
				"sourceMap": "955:1482:0:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;955:1482:0;;;;;;;"
			},
			"deployedBytecode": {
				"linkReferences": {},
				"object": "0x6080604052600436106100565763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663b4f2e8b8811461005b578063b88c914814610096578063e487721a146100db575b600080fd5b34801561006757600080fd5b506100946004803603604081101561007e57600080fd5b5080359060200135600160a060020a0316610113565b005b3480156100a257600080fd5b506100c9600480360360208110156100b957600080fd5b5035600160a060020a031661016a565b60408051918252519081900360200190f35b610094600480360360608110156100f157600080fd5b50600160a060020a038135811691602081013582169160409091013516610185565b600160a060020a03811660009081526020819052604090205481901561013857600080fd5b81600160a060020a038116151561014e57600080fd5b5050600160a060020a0316600090815260208190526040902055565b600160a060020a031660009081526020819052604090205490565b82600160a060020a031663af41cec0826040518263ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018082600160a060020a0316600160a060020a03168152602001915050602060405180830381600087803b1580156101f957600080fd5b505af115801561020d573d6000803e3d6000fd5b505050506040513d602081101561022357600080fd5b5050600160a060020a0382166000908152602081905260408120546102559061024d903490610326565b612710610351565b905060006102633483610386565b604051909150600160a060020a0386169082156108fc029083906000818181858888f1935050505015801561029c573d6000803e3d6000fd5b50604051600160a060020a0385169083156108fc029084906000818181858888f193505050501580156102d3573d6000803e3d6000fd5b5083600160a060020a031683600160a060020a03167f4d1db39debc799df6a6a3bad1c8809c46cbe6eb3b784df03f50a061c487994c6836040518082815260200191505060405180910390a35050505050565b6000828202831580610342575082848281151561033f57fe5b04145b151561034a57fe5b9392505050565b600080821161035c57fe5b6000828481151561036957fe5b049050828481151561037757fe5b06818402018414151561034a57fe5b60008282111561039257fe5b5090039056fea165627a7a723058205ee9a6dafa856c3b9397d9034e45de70a0b2529b86e2c1068be56515ce97d60d0029",
				"opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH2 0x56 JUMPI PUSH4 0xFFFFFFFF PUSH29 0x100000000000000000000000000000000000000000000000000000000 PUSH1 0x0 CALLDATALOAD DIV AND PUSH4 0xB4F2E8B8 DUP2 EQ PUSH2 0x5B JUMPI DUP1 PUSH4 0xB88C9148 EQ PUSH2 0x96 JUMPI DUP1 PUSH4 0xE487721A EQ PUSH2 0xDB JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0x67 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0x94 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0x7E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD CALLDATALOAD PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB AND PUSH2 0x113 JUMP JUMPDEST STOP JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0xA2 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0xC9 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x20 DUP2 LT ISZERO PUSH2 0xB9 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP CALLDATALOAD PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB AND PUSH2 0x16A JUMP JUMPDEST PUSH1 0x40 DUP1 MLOAD SWAP2 DUP3 MSTORE MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x20 ADD SWAP1 RETURN JUMPDEST PUSH2 0x94 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x60 DUP2 LT ISZERO PUSH2 0xF1 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB DUP2 CALLDATALOAD DUP2 AND SWAP2 PUSH1 0x20 DUP2 ADD CALLDATALOAD DUP3 AND SWAP2 PUSH1 0x40 SWAP1 SWAP2 ADD CALLDATALOAD AND PUSH2 0x185 JUMP JUMPDEST PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB DUP2 AND PUSH1 0x0 SWAP1 DUP2 MSTORE PUSH1 0x20 DUP2 SWAP1 MSTORE PUSH1 0x40 SWAP1 KECCAK256 SLOAD DUP2 SWAP1 ISZERO PUSH2 0x138 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB DUP2 AND ISZERO ISZERO PUSH2 0x14E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP POP PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB AND PUSH1 0x0 SWAP1 DUP2 MSTORE PUSH1 0x20 DUP2 SWAP1 MSTORE PUSH1 0x40 SWAP1 KECCAK256 SSTORE JUMP JUMPDEST PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB AND PUSH1 0x0 SWAP1 DUP2 MSTORE PUSH1 0x20 DUP2 SWAP1 MSTORE PUSH1 0x40 SWAP1 KECCAK256 SLOAD SWAP1 JUMP JUMPDEST DUP3 PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB AND PUSH4 0xAF41CEC0 DUP3 PUSH1 0x40 MLOAD DUP3 PUSH4 0xFFFFFFFF AND PUSH29 0x100000000000000000000000000000000000000000000000000000000 MUL DUP2 MSTORE PUSH1 0x4 ADD DUP1 DUP3 PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB AND PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x1F9 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x20D JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x223 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP POP PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB DUP3 AND PUSH1 0x0 SWAP1 DUP2 MSTORE PUSH1 0x20 DUP2 SWAP1 MSTORE PUSH1 0x40 DUP2 KECCAK256 SLOAD PUSH2 0x255 SWAP1 PUSH2 0x24D SWAP1 CALLVALUE SWAP1 PUSH2 0x326 JUMP JUMPDEST PUSH2 0x2710 PUSH2 0x351 JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0x263 CALLVALUE DUP4 PUSH2 0x386 JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 SWAP2 POP PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB DUP7 AND SWAP1 DUP3 ISZERO PUSH2 0x8FC MUL SWAP1 DUP4 SWAP1 PUSH1 0x0 DUP2 DUP2 DUP2 DUP6 DUP9 DUP9 CALL SWAP4 POP POP POP POP ISZERO DUP1 ISZERO PUSH2 0x29C JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB DUP6 AND SWAP1 DUP4 ISZERO PUSH2 0x8FC MUL SWAP1 DUP5 SWAP1 PUSH1 0x0 DUP2 DUP2 DUP2 DUP6 DUP9 DUP9 CALL SWAP4 POP POP POP POP ISZERO DUP1 ISZERO PUSH2 0x2D3 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP DUP4 PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB AND DUP4 PUSH1 0x1 PUSH1 0xA0 PUSH1 0x2 EXP SUB AND PUSH32 0x4D1DB39DEBC799DF6A6A3BAD1C8809C46CBE6EB3B784DF03F50A061C487994C6 DUP4 PUSH1 0x40 MLOAD DUP1 DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 LOG3 POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP3 DUP3 MUL DUP4 ISZERO DUP1 PUSH2 0x342 JUMPI POP DUP3 DUP5 DUP3 DUP2 ISZERO ISZERO PUSH2 0x33F JUMPI INVALID JUMPDEST DIV EQ JUMPDEST ISZERO ISZERO PUSH2 0x34A JUMPI INVALID JUMPDEST SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 DUP3 GT PUSH2 0x35C JUMPI INVALID JUMPDEST PUSH1 0x0 DUP3 DUP5 DUP2 ISZERO ISZERO PUSH2 0x369 JUMPI INVALID JUMPDEST DIV SWAP1 POP DUP3 DUP5 DUP2 ISZERO ISZERO PUSH2 0x377 JUMPI INVALID JUMPDEST MOD DUP2 DUP5 MUL ADD DUP5 EQ ISZERO ISZERO PUSH2 0x34A JUMPI INVALID JUMPDEST PUSH1 0x0 DUP3 DUP3 GT ISZERO PUSH2 0x392 JUMPI INVALID JUMPDEST POP SWAP1 SUB SWAP1 JUMP INVALID LOG1 PUSH6 0x627A7A723058 KECCAK256 0x5e 0xe9 0xa6 0xda STATICCALL DUP6 PUSH13 0x3B9397D9034E45DE70A0B2529B DUP7 0xe2 0xc1 MOD DUP12 0xe5 PUSH6 0x15CE97D60D00 0x29 ",
				"sourceMap": "955:1482:0:-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2019:219;;8:9:-1;5:2;;;30:1;27;20:12;5:2;2019:219:0;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;-1:-1;2019:219:0;;;;;;-1:-1:-1;;;;;2019:219:0;;;;;2292:143;;8:9:-1;5:2;;;30:1;27;20:12;5:2;2292:143:0;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;-1:-1;2292:143:0;-1:-1:-1;;;;;2292:143:0;;;;;;;;;;;;;;;;;;;1488:525;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;-1:-1;;;;;;1488:525:0;;;;;;;;;;;;;;;;;;;;2019:219;-1:-1:-1;;;;;1287:25:0;;:11;:25;;;;;;;;;;:29;2130:12;;1287:34;1279:43;;;;;;2167:12;-1:-1:-1;;;;;1405:21:0;;;;1397:30;;;;;;-1:-1:-1;;;;;;;2195:25:0;:11;:25;;;;;;;;;;:36;2019:219::o;2292:143::-;-1:-1:-1;;;;;2399:25:0;2369:7;2399:25;;;;;;;;;;:29;;2292:143::o;1488:525::-;1659:5;-1:-1:-1;;;;;1653:29:0;;1683:6;1653:37;;;;;;;;;;;;;-1:-1:-1;;;;;1653:37:0;-1:-1:-1;;;;;1653:37:0;;;;;;;;;;;;;;;;;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;1653:37:0;;;;8:9:-1;5:2;;;45:16;42:1;39;24:38;77:16;74:1;67:27;5:2;1653:37:0;;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;-1:-1;;;;;;;1747:25:0;;1700:17;1747:25;;;1653:37;1747:25;;;;;;:29;1720:65;;1728:49;;1736:9;;1728:7;:49::i;:::-;1779:5;1720:7;:65::i;:::-;1700:85;;1820:17;1840:29;1848:9;1859;1840:7;:29::i;:::-;1879:25;;1820:49;;-1:-1:-1;;;;;;1879:14:0;;;:25;;;;;1820:49;;1879:25;;;;1820:49;1879:14;:25;;;;;;;;8:9:-1;5:2;;;45:16;42:1;39;24:38;77:16;74:1;67:27;5:2;-1:-1;1914:32:0;;-1:-1:-1;;;;;1914:21:0;;;:32;;;;;1936:9;;1914:32;;;;1936:9;1914:21;:32;;;;;;;;8:9:-1;5:2;;;45:16;42:1;39;24:38;77:16;74:1;67:27;5:2;1914:32:0;1982:12;-1:-1:-1;;;;;1961:45:0;1974:6;-1:-1:-1;;;;;1961:45:0;;1996:9;1961:45;;;;;;;;;;;;;;;;;;1488:525;;;;;:::o;54:161:41:-;116:7;147:5;;;169:6;;;:20;;;188:1;183;179;:5;;;;;;;;:10;169:20;162:28;;;;;;207:1;54:161;-1:-1:-1;;;54:161:41:o;221:182::-;283:7;309:5;;;302:13;;;;325:9;341:1;337;:5;;;;;;;;325:17;;376:1;372;:5;;;;;;;;368:1;364;:5;:13;359:1;:18;352:26;;;;;409:124;471:7;497:6;;;;490:14;;;;-1:-1:-1;521:5:41;;;409:124::o"
			}
		}
	},
	"sourceTreeHashHex": "0xb5e25d0b8f5ac9198efebef469720fcd75f8a1f16216fa5f39b30dd953f1a233",
	"sources": {
		"./Distribution.sol": {
			"id": 0
		},
		"../../protocol/Vault/Vault.sol": {
			"id": 9
		},
		"../../protocol/authorities/Authority/AuthorityFace.sol": {
			"id": 14
		},
		"../../protocol/VaultEventful/VaultEventfulFace.sol": {
			"id": 12
		},
		"../../tokens/ERC20/ERC20Face.sol": {
			"id": 30
		},
		"../../utils/ReentrancyGuard/ReentrancyGuard.sol": {
			"id": 39
		},
		"../../protocol/Vault/VaultFace.sol": {
			"id": 10
		},
		"../../utils/Owned/OwnedUninitialized.sol": {
			"id": 38
		},
		"../../utils/SafeMath/SafeMathLight.sol": {
			"id": 41
		},
		"./DistributionFace.sol": {
			"id": 1
		}
	},
	"sourceCodes": {
		"./Distribution.sol": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.0;\n\nimport { VaultFace as Vault } from \"../../protocol/Vault/Vault.sol\";\nimport { DistributionFace } from \"./DistributionFace.sol\";\nimport { SafeMathLight as SafeMath } from \"../../utils/SafeMath/SafeMathLight.sol\";\n\n/// @title Distribution - Allows to collect subscription fees on vaults.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\ncontract Distribution is\n    SafeMath\n{\n    event Subscription(\n        address indexed buyer,\n        address indexed distributor,\n        uint256 amount\n    );\n\n    mapping (address => Distributor) distributor;\n\n    struct Distributor {\n        uint256 fee;\n    }\n\n    modifier addressFree(address _distributor) {\n        require(distributor[_distributor].fee == 0);\n        _;\n    }\n\n    modifier nonZeroAddress(address _target) {\n        require(_target != address(0));\n        _;\n    }\n\n    /*\n     * CORE FUNCTIONS\n     */\n    function subscribe(\n        address payable _pool,\n        address payable _distributor,\n        address _buyer\n    )\n        external\n        payable\n    {\n        Vault(_pool).buyVaultOnBehalf(_buyer);\n        uint256 feeAmount = safeDiv(safeMul(msg.value, distributor[_distributor].fee), 10000); //fee is in basis points\n        uint256 netAmount = safeSub(msg.value, feeAmount);\n        _pool.transfer(netAmount);\n        _distributor.transfer(feeAmount);\n        emit Subscription(_buyer, _distributor, netAmount);\n    }\n\n    function setFee(\n        uint256 _fee,\n        address _distributor\n    )\n        external\n        addressFree(_distributor)\n        nonZeroAddress(_distributor)\n    {\n        distributor[_distributor].fee = _fee;\n    }\n\n    /*\n     * CONSTANT PUBLIC FUNCTIONS\n     */\n    function getFee(address _distributor)\n        external view\n        returns (uint256)\n    {\n        return distributor[_distributor].fee;\n    }\n}\n",
		"../../protocol/Vault/Vault.sol": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.0;\n\nimport { AuthorityFace as Authority } from \"../authorities/Authority/AuthorityFace.sol\";\nimport { VaultEventfulFace as VaultEventful } from \"../VaultEventful/VaultEventfulFace.sol\";\nimport { ERC20Face as Token } from \"../../tokens/ERC20/ERC20Face.sol\";\nimport { ReentrancyGuard } from \"../../utils/ReentrancyGuard//ReentrancyGuard.sol\";\nimport { VaultFace } from \"./VaultFace.sol\";\nimport { OwnedUninitialized as Owned } from \"../../utils/Owned/OwnedUninitialized.sol\";\nimport { SafeMathLight as SafeMath } from \"../../utils/SafeMath/SafeMathLight.sol\";\n\n/// @title Vault - contract for creating a vault type of pool.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ncontract Vault is Owned, SafeMath, ReentrancyGuard, VaultFace {\n\n    string constant VERSION = 'VC 0.5.2';\n    uint256 constant BASE = 1000000; //tokens are divisible by 1 million\n\n    VaultData data;\n    Admin admin;\n\n    mapping (address => Account) accounts;\n\n    mapping (address => uint256) totalTokens;\n    mapping (address => mapping (address => uint256)) public depositLock;\n    mapping (address => mapping (address => uint256)) public tokenBalances;\n\n    struct Receipt {\n        uint32 activation;\n    }\n\n    struct Account {\n        uint256 balance;\n        Receipt receipt;\n    }\n\n    struct VaultData {\n        string name;\n        string symbol;\n        uint256 vaultId;\n        uint256 totalSupply;\n        uint256 price;\n        uint256 transactionFee; // fee is in basis points (1 bps = 0.01%)\n        uint32 minPeriod;\n        uint128 validatorIndex;\n    }\n\n    struct Admin {\n        address authority;\n        address vaultDao;\n        address feeCollector;\n        uint256 minOrder; // minimum stake to avoid dust clogging things up\n        uint256 ratio; // ratio is 80%\n    }\n\n    modifier onlyVaultDao {\n        require(msg.sender == admin.vaultDao);\n        _;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier minimumStake(uint256 _amount) {\n        require(_amount >= admin.minOrder);\n        _;\n    }\n\n    modifier hasEnough(uint256 _amount) {\n        require(accounts[msg.sender].balance >= _amount);\n        _;\n    }\n\n    modifier positiveAmount(uint256 _amount) {\n        require(accounts[msg.sender].balance + _amount > accounts[msg.sender].balance);\n        _;\n    }\n\n    modifier minimumPeriodPast {\n        require(now >= accounts[msg.sender].receipt.activation);\n        _;\n    }\n\n    constructor(\n        string memory _vaultName,\n        string memory _vaultSymbol,\n        uint256 _vaultId,\n        address _owner,\n        address _authority)\n        public\n    {\n        data.name = _vaultName;\n        data.symbol = _vaultSymbol;\n        data.vaultId = _vaultId;\n        data.price = 1 ether; //initial price is 1 Ether\n        owner = _owner;\n        admin.authority = _authority;\n        admin.vaultDao = msg.sender;\n        admin.minOrder = 1 finney;\n        admin.feeCollector = _owner;\n        admin.ratio = 80;\n    }\n\n    /*\n     * CORE FUNCTIONS\n     */\n    /// @dev Allows a user to buy into a vault\n    /// @return Bool the function executed correctly\n    function buyVault()\n        external\n        payable\n        minimumStake(msg.value)\n        returns (bool success)\n    {\n        require(buyVaultInternal(msg.sender, msg.value));\n        return true;\n    }\n\n    /// @dev Allows a user to buy into a vault on behalf of an address\n    /// @param _hodler Address of the target user\n    /// @return Bool the function executed correctly\n    function buyVaultOnBehalf(address _hodler)\n        external\n        payable\n        minimumStake(msg.value)\n        returns (bool success)\n    {\n        require(buyVaultInternal(_hodler, msg.value));\n        return true;\n    }\n\n    /// @dev Allows a user to sell from a vault\n    /// @param _amount Number of shares to sell\n    /// @return Bool the function executed correctly\n    function sellVault(uint256 _amount)\n        external\n        nonReentrant\n        hasEnough(_amount)\n        positiveAmount(_amount)\n        minimumPeriodPast\n        returns (bool success)\n    {\n        updatePriceInternal();\n        uint256 feeVault;\n        uint256 feeVaultDao;\n        uint256 netAmount;\n        uint256 netRevenue;\n        (feeVault, feeVaultDao, netAmount, netRevenue) = getSaleAmounts(_amount);\n        addSaleLog(_amount, netRevenue);\n        allocateSaleTokens(msg.sender, _amount, feeVault, feeVaultDao);\n        data.totalSupply = safeSub(data.totalSupply, netAmount);\n        msg.sender.transfer(netRevenue);\n        return true;\n    }\n\n    /// @dev Allows vault dao/factory to change fee split ratio\n    /// @param _ratio Number of ratio for wizard, from 0 to 100\n    function changeRatio(uint256 _ratio)\n        external\n        onlyVaultDao\n    {\n        Authority auth = Authority(admin.authority);\n        VaultEventful events = VaultEventful(auth.getVaultEventful());\n        require(events.changeRatio(msg.sender, address(this), _ratio));\n        admin.ratio = _ratio;\n    }\n\n    /// @dev Allows vault owner to set the transaction fee\n    /// @param _transactionFee Value of the transaction fee in basis points\n    function setTransactionFee(uint256 _transactionFee)\n        external\n        onlyOwner\n    {\n        require(_transactionFee <= 100); //fee cannot be higher than 1%\n        Authority auth = Authority(admin.authority);\n        VaultEventful events = VaultEventful(auth.getVaultEventful());\n        require(events.setTransactionFee(msg.sender, address(this), _transactionFee));\n        data.transactionFee = _transactionFee;\n    }\n\n    /// @dev Allows owner to decide where to receive the fee\n    /// @param _feeCollector Address of the fee receiver\n    function changeFeeCollector(address _feeCollector)\n        external\n        onlyOwner\n    {\n        Authority auth = Authority(admin.authority);\n        VaultEventful events = VaultEventful(auth.getVaultEventful());\n        require(events.changeFeeCollector(msg.sender, address(this), _feeCollector));\n        admin.feeCollector = _feeCollector;\n    }\n\n    /// @dev Allows vault dao/factory to upgrade its address\n    /// @param _vaultDao Address of the new vault dao\n    function changeVaultDao(address _vaultDao)\n        external\n        onlyVaultDao\n    {\n        Authority auth = Authority(admin.authority);\n        VaultEventful events = VaultEventful(auth.getVaultEventful());\n        require(events.changeVaultDao(msg.sender, address(this), _vaultDao));\n        admin.vaultDao = _vaultDao;\n    }\n\n    /// @dev Allows anyone to pay and update the price\n    /// @dev This function allows to write the new nav\n    /// @dev NAV is provided by view functions\n    function updatePrice()\n        external\n        nonReentrant\n    {\n        updatePriceInternal();\n    }\n\n    /// @dev Allows vault dao/factory to change the minimum holding period\n    /// @param _minPeriod Lockup time in seconds\n    function changeMinPeriod(uint32 _minPeriod)\n        external\n        onlyVaultDao\n    {\n        data.minPeriod = _minPeriod;\n    }\n\n    /// @dev Allows anyone to deposit tokens to a vault\n    /// @param _token Address of the token\n    /// @param _value Amount to deposit\n    /// @param _forTime Lockup time in seconds\n    /// @notice lockup time can be zero\n    function depositToken(\n        address _token,\n        uint256 _value,\n        uint8 _forTime)\n        external\n        nonReentrant\n        returns (bool success)\n    {\n        require(depositTokenInternal(_token, msg.sender, _value, _forTime));\n        return true;\n    }\n\n    /// @dev Allows anyone to deposit tokens to a vault on behalf of someone\n    /// @param _token Address of the token\n    /// @param _value Amount to deposit\n    /// @param _forTime Lockup time in seconds\n    /// @notice lockup time can be zero\n    function depositTokenOnBehalf(\n        address _token,\n        address _hodler,\n        uint256 _value,\n        uint8 _forTime)\n        external\n        returns (bool success)\n    {\n        require(depositTokenInternal(_token, _hodler, _value, _forTime));\n        return true;\n    }\n\n    /// @dev Allows anyone to withdraw tokens from a vault\n    /// @param _token Address of the token\n    /// @param _value Amount to withdraw\n    /// @return Bool the transaction was successful\n    function withdrawToken(\n        address _token,\n        uint256 _value)\n        external\n        nonReentrant\n        returns\n        (bool success)\n    {\n        require(tokenBalances[_token][msg.sender] >= _value);\n        require(uint32(now) > depositLock[_token][msg.sender]);\n        tokenBalances[_token][msg.sender] = safeSub(tokenBalances[_token][msg.sender], _value);\n        totalTokens[_token] = safeSub(totalTokens[_token], _value);\n        require(Token(_token).transfer(msg.sender, _value));\n        return true;\n    }\n\n    /*\n     * CONSTANT PUBLIC FUNCTIONS\n     */\n    /// @dev Calculates how many shares a user holds\n    /// @param _from Address of the target account\n    /// @return Number of shares\n    function balanceOf(address _from)\n        external\n        view\n        returns (uint256)\n    {\n        return accounts[_from].balance;\n    }\n\n    /// @dev Returns a user balance of a certain deposited token\n    /// @param _token Address of the token\n    /// @param _owner Address of the user\n    /// @return Number of tokens\n    function tokenBalanceOf(\n        address _token,\n        address _owner)\n        external\n        view\n        returns (uint256)\n    {\n        return tokenBalances[_token][_owner];\n    }\n\n    /// @dev Returns the time needed to withdraw\n    /// @param _token Address of the token\n    /// @param _user Address of the user\n    /// @return Time in seconds\n    function timeToUnlock(\n        address _token,\n        address _user)\n        external\n        view\n        returns (uint256)\n    {\n        return depositLock[_token][_user];\n    }\n\n    /// @dev Returns the amount of tokens of a certain token in vault\n    /// @param _token Address of the token\n    /// @return _value in custody\n    function tokensInVault(address _token)\n        external\n        view\n        returns (uint256)\n    {\n        return totalTokens[_token];\n    }\n\n    /// @dev Gets the address of the logger contract\n    /// @return Address of the logger contrac\n    function getEventful()\n        external\n        view\n        returns (address)\n    {\n        Authority auth = Authority(admin.authority);\n        return auth.getVaultEventful();\n    }\n\n    /// @dev Finds details of a vault pool\n    /// @return String name of a vault\n    /// @return String symbol of a vault\n    /// @return Value of the share price in wei\n    /// @return Value of the share price in wei\n    function getData()\n        external\n        view\n        returns (\n            string memory name,\n            string memory symbol,\n            uint256 sellPrice,\n            uint256 buyPrice\n        )\n    {\n        return(\n            name = data.name,\n            symbol = data.symbol,\n            sellPrice = getNav(),\n            buyPrice = getNav()\n        );\n    }\n\n    /// @dev Returns the price of a pool\n    /// @return Value of the share price in wei\n    function calcSharePrice()\n        external\n        view\n        returns (uint256)\n    {\n        return getNav();\n    }\n\n    /// @dev Finds the administrative data of the pool\n    /// @return Address of the account where a user collects fees\n    /// @return Address of the vault dao/factory\n    /// @return Number of the fee split ratio\n    /// @return Value of the transaction fee in basis points\n    /// @return Number of the minimum holding period for shares\n    function getAdminData()\n        external\n        view\n        returns (\n            address,\n            address feeCollector,\n            address vaultDao,\n            uint256 ratio,\n            uint256 transactionFee,\n            uint32 minPeriod\n        )\n    {\n        return (\n            owner,\n            admin.feeCollector,\n            admin.vaultDao,\n            admin.ratio,\n            data.transactionFee,\n            data.minPeriod\n        );\n    }\n\n    /// @dev Returns the total amount of issued tokens for this vault\n    /// @return Number of shares\n    function totalSupply()\n        external\n        view\n        returns (uint256)\n    {\n        return data.totalSupply;\n    }\n\n    /*\n     * INTERNAL FUNCTIONS\n     */\n    /// @dev Executes purchase function\n    /// @param _hodler Address of the target user\n    /// @return Bool the function executed correctly\n    function buyVaultInternal(\n        address _hodler,\n        uint256 _totalEth)\n        internal\n        returns (bool success)\n    {\n        updatePriceInternal();\n        uint256 grossAmount;\n        uint256 feeVault;\n        uint256 feeVaultDao;\n        uint256 amount;\n        (grossAmount, feeVault, feeVaultDao, amount) = getPurchaseAmounts(_totalEth);\n        addPurchaseLog(amount);\n        allocatePurchaseTokens(_hodler, amount, feeVault, feeVaultDao);\n        data.totalSupply = safeAdd(data.totalSupply, grossAmount);\n        return true;\n    }\n\n    /// @dev Updates the price\n    function updatePriceInternal()\n        internal\n    {\n        if (address(this).balance > 0) {\n            data.price = getNav();\n        }\n    }\n\n    /// @dev Allocates tokens to buyer, splits fee in tokens to wizard and dao\n    /// @param _hodler Address of the buyer\n    /// @param _amount Value of issued tokens\n    /// @param _feeVault Number of shares as fee\n    /// @param _feeVaultDao Number of shares as fee to dao\n    function allocatePurchaseTokens(\n        address _hodler,\n        uint256 _amount,\n        uint256 _feeVault,\n        uint256 _feeVaultDao)\n        internal\n    {\n        accounts[_hodler].balance = safeAdd(accounts[_hodler].balance, _amount);\n        accounts[admin.feeCollector].balance = safeAdd(accounts[admin.feeCollector].balance, _feeVault);\n        accounts[admin.vaultDao].balance = safeAdd(accounts[admin.vaultDao].balance, _feeVaultDao);\n        accounts[_hodler].receipt.activation = uint32(now) + data.minPeriod;\n    }\n\n    /// @dev Destroys tokens from buyer, splits fee in tokens to wizard and dao\n    /// @param _hodler Address of the seller\n    /// @param _amount Value of burnt tokens\n    /// @param _feeVault Number of shares as fee\n    /// @param _feeVaultDao Number of shares as fee to dao\n    function allocateSaleTokens(\n        address _hodler,\n        uint256 _amount,\n        uint256 _feeVault,\n        uint256 _feeVaultDao)\n        internal\n    {\n        accounts[_hodler].balance = safeSub(accounts[_hodler].balance, _amount);\n        accounts[admin.feeCollector].balance = safeAdd(accounts[admin.feeCollector].balance, _feeVault);\n        accounts[admin.vaultDao].balance = safeAdd(accounts[admin.vaultDao].balance, _feeVaultDao);\n    }\n\n    /// @dev Sends a buy log to the eventful contract\n    /// @param _amount Number of purchased shares\n    function addPurchaseLog(uint256 _amount)\n        internal\n    {\n        bytes memory name = bytes(data.name);\n        bytes memory symbol = bytes(data.symbol);\n        Authority auth = Authority(admin.authority);\n        VaultEventful events = VaultEventful(auth.getVaultEventful());\n        require(events.buyVault(msg.sender, address(this), msg.value, _amount, name, symbol));\n    }\n\n    /// @dev Sends a sell log to the eventful contract\n    /// @param _amount Number of sold shares\n    /// @param _netRevenue Value of sale for hodler\n    function addSaleLog(\n        uint256 _amount,\n        uint256 _netRevenue)\n        internal\n    {\n        bytes memory name = bytes(data.name);\n        bytes memory symbol = bytes(data.symbol);\n        Authority auth = Authority(admin.authority);\n        VaultEventful events = VaultEventful(auth.getVaultEventful());\n        require(events.sellVault(msg.sender, address(this), _amount, _netRevenue, name, symbol));\n    }\n\n    /// @dev Executes a deposit\n    /// @param _token Address of the token to be deposited\n    /// @param _hodler Address of the hodler\n    /// @param _value Amount of tokens\n    /// @param _forTime Time in seconds of lockup\n    /// @return Bool the transaction was successful\n    function depositTokenInternal(\n        address _token,\n        address _hodler,\n        uint256 _value,\n        uint8 _forTime)\n        internal\n        returns (bool success)\n    {\n        require(now + _forTime >= depositLock[_token][_hodler]);\n        require(Token(_token).approve(address(this), _value));\n        require(Token(_token).transferFrom(msg.sender, address(this), _value));\n        tokenBalances[_token][_hodler] = safeAdd(tokenBalances[_token][_hodler], _value);\n        totalTokens[_token] = safeAdd(totalTokens[_token], _value);\n        depositLock[_token][_hodler] = safeAdd(uint(now), _forTime);\n        return true;\n    }\n\n    /// @dev Calculates the correct purchase amounts\n    /// @return Number of new shares\n    /// @return Value of fee in shares\n    /// @return Value of fee in shares to dao\n    /// @return Value of net purchased shares\n    function getPurchaseAmounts(uint256 _totalEth)\n        internal\n        view\n        returns (\n            uint256 grossAmount,\n            uint256 feeVault,\n            uint256 feeVaultDao,\n            uint256 amount\n        )\n    {\n        grossAmount = safeDiv(_totalEth * BASE, data.price);\n        uint256 fee = safeMul(grossAmount, data.transactionFee) / 10000; //fee is in basis points\n        return (\n            grossAmount,\n            feeVault = safeMul(fee , admin.ratio) / 100,\n            feeVaultDao = safeSub(fee, feeVault),\n            amount = safeSub(grossAmount, fee)\n        );\n    }\n\n    /// @dev Calculates the correct sale amounts\n    /// @return Value of fee in shares\n    /// @return Value of fee in shares to dao\n    /// @return Value of net sold shares\n    /// @return Value of sale amount for hodler\n    function getSaleAmounts(uint256 _amount)\n        internal\n        view\n        returns (\n            uint256 feeVault,\n            uint256 feeVaultDao,\n            uint256 netAmount,\n            uint256 netRevenue\n        )\n    {\n        uint256 fee = safeMul(_amount, data.transactionFee) / 10000; //fee is in basis points\n        return (\n            feeVault = safeMul(fee, admin.ratio) / 100,\n            feeVaultDao = safeSub(fee, feeVaultDao),\n            netAmount = safeSub(_amount, fee),\n            netRevenue = (safeMul(netAmount, data.price) / BASE)\n        );\n    }\n\n    /// @dev Calculates the value of the shares\n    /// @return Value of the shares in wei\n    function getNav()\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 aum = address(this).balance - msg.value;\n        return (data.totalSupply == 0 ? data.price : safeDiv(aum * BASE, data.totalSupply));\n    }\n}\n",
		"../../protocol/authorities/Authority/AuthorityFace.sol": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity >=0.4.22 <0.8.0;\n\n/// @title Authority Interface - Allows interaction with the Authority contract.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ninterface AuthorityFace {\n\n    /*\n     * EVENTS\n     */\n    event AuthoritySet(address indexed authority);\n    event WhitelisterSet(address indexed whitelister);\n    event WhitelistedUser(address indexed target, bool approved);\n    event WhitelistedRegistry(address indexed registry, bool approved);\n    event WhitelistedFactory(address indexed factory, bool approved);\n    event WhitelistedVault(address indexed vault, bool approved);\n    event WhitelistedDrago(address indexed drago, bool isWhitelisted);\n    event NewDragoEventful(address indexed dragoEventful);\n    event NewVaultEventful(address indexed vaultEventful);\n    event NewNavVerifier(address indexed navVerifier);\n    event NewExchangesAuthority(address indexed exchangesAuthority);\n\n    /*\n     * CORE FUNCTIONS\n     */\n    function setAuthority(address _authority, bool _isWhitelisted) external;\n    function setWhitelister(address _whitelister, bool _isWhitelisted) external;\n    function whitelistUser(address _target, bool _isWhitelisted) external;\n    function whitelistDrago(address _drago, bool _isWhitelisted) external;\n    function whitelistVault(address _vault, bool _isWhitelisted) external;\n    function whitelistRegistry(address _registry, bool _isWhitelisted) external;\n    function whitelistFactory(address _factory, bool _isWhitelisted) external;\n    function setDragoEventful(address _dragoEventful) external;\n    function setVaultEventful(address _vaultEventful) external;\n    function setNavVerifier(address _navVerifier) external;\n    function setExchangesAuthority(address _exchangesAuthority) external;\n\n    /*\n     * CONSTANT PUBLIC FUNCTIONS\n     */\n    function isWhitelistedUser(address _target) external view returns (bool);\n    function isAuthority(address _authority) external view returns (bool);\n    function isWhitelistedRegistry(address _registry) external view returns (bool);\n    function isWhitelistedDrago(address _drago) external view returns (bool);\n    function isWhitelistedVault(address _vault) external view returns (bool);\n    function isWhitelistedFactory(address _factory) external view returns (bool);\n    function getDragoEventful() external view returns (address);\n    function getVaultEventful() external view returns (address);\n    function getNavVerifier() external view returns (address);\n    function getExchangesAuthority() external view returns (address);\n}\n",
		"../../protocol/VaultEventful/VaultEventfulFace.sol": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.0;\n\n/// @title Vault Eventful Interface - Logs all vaults transactions.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ninterface VaultEventfulFace {\n\n    /*\n     * EVENTS\n     */\n    event BuyVault(address indexed vault, address indexed from, address indexed to, uint256 amount, uint256 revenue, bytes name, bytes symbol);\n    event SellVault(address indexed vault, address indexed from, address indexed to, uint256 amount, uint256 revenue, bytes name, bytes symbol);\n    event NewRatio(address indexed vault, address indexed from, uint256 newRatio);\n    event NewFee(address indexed vault, address indexed from, address indexed to, uint256 fee);\n    event NewCollector(address indexed vault, address indexed from, address indexed to, address collector);\n    event VaultDao(address indexed vault, address indexed from, address indexed to, address vaultDao);\n    event VaultCreated(address indexed vault, address indexed group, address indexed owner, uint256 vaultId, string name, string symbol);\n\n    /*\n     * CORE FUNCTIONS\n     */\n    function buyVault(address _who, address _targetVault, uint256 _value, uint256 _amount, bytes calldata _name, bytes calldata _symbol) external returns (bool success);\n    function sellVault(address _who, address _targetVault, uint256 _amount, uint256 _revenue, bytes calldata _name, bytes calldata _symbol) external returns(bool success);\n    function changeRatio(address _who, address _targetVault, uint256 _ratio) external returns(bool success);\n    function setTransactionFee(address _who, address _targetVault, uint256 _transactionFee) external returns(bool success);\n    function changeFeeCollector(address _who, address _targetVault, address _feeCollector) external returns(bool success);\n    function changeVaultDao(address _who, address _targetVault, address _vaultDao) external returns(bool success);\n    function createVault(address _who, address _newVault, string calldata _name, string calldata _symbol, uint256 _vaultId) external returns(bool success);\n}\n",
		"../../tokens/ERC20/ERC20Face.sol": "pragma solidity >=0.5.0;\n\ninterface ERC20Face {\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function balanceOf(address _who) external view returns (uint256);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n}\n",
		"../../utils/ReentrancyGuard/ReentrancyGuard.sol": "/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ReentrancyGuard {\n\n    // Locked state of mutex\n    bool private locked = false;\n\n    /// @dev Functions with this modifer cannot be reentered. The mutex will be locked\n    ///      before function execution and unlocked after.\n    modifier nonReentrant() {\n        // Ensure mutex is unlocked\n        require(\n            !locked,\n            \"REENTRANCY_ILLEGAL\"\n        );\n\n        // Lock mutex before function call\n        locked = true;\n\n        // Perform function call\n        _;\n\n        // Unlock mutex after function call\n        locked = false;\n    }\n}\n",
		"../../protocol/Vault/VaultFace.sol": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.0;\n\n/// @title Vault Interface - Allows interaction with the Vault contracts.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ninterface VaultFace {\n\n    /*\n     * CORE FUNCTIONS\n     */\n    function buyVault() external payable returns (bool success);\n    function buyVaultOnBehalf(address _hodler) external payable returns (bool success);\n    function sellVault(uint256 amount) external returns (bool success);\n    function changeRatio(uint256 _ratio) external;\n    function setTransactionFee(uint256 _transactionFee) external;\n    function changeFeeCollector(address _feeCollector) external;\n    function changeVaultDao(address _vaultDao) external;\n    function updatePrice() external;\n    function changeMinPeriod(uint32 _minPeriod) external;\n    function depositToken(address _token, uint256 _value, uint8 _forTime) external returns (bool success);\n    function depositTokenOnBehalf(address _token, address _hodler, uint256 _value, uint8 _forTime) external returns (bool success);\n    function withdrawToken(address _token, uint256 _value) external returns (bool success);\n\n    /*\n     * CONSTANT PUBLIC FUNCTIONS\n     */\n    function balanceOf(address _who) external view returns (uint256);\n    function tokenBalanceOf(address _token, address _owner) external view returns (uint256);\n    function timeToUnlock(address _token, address _user) external view returns (uint256);\n    function tokensInVault(address _token) external view returns (uint256);\n    function getEventful() external view returns (address);\n    function getData() external view returns (string memory name, string memory symbol, uint256 sellPrice, uint256 buyPrice);\n    function calcSharePrice() external view returns (uint256);\n    function getAdminData() external view returns (address, address feeCollector, address vaultDao, uint256 ratio, uint256 transactionFee, uint32 minPeriod);\n    function totalSupply() external view returns (uint256);\n}\n",
		"../../utils/Owned/OwnedUninitialized.sol": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract OwnedUninitialized {\n\n    address public owner;\n\n    event NewOwner(address indexed old, address indexed current);\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function setOwner(address _new) public onlyOwner {\n        require(_new != address(0));\n        owner = _new;\n        emit  NewOwner(owner, _new);\n    }\n}\n",
		"../../utils/SafeMath/SafeMathLight.sol": "pragma solidity 0.5.0;\n\ncontract SafeMathLight {\n\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b > 0);\n        uint256 c = a / b;\n        assert(a == b * c + a % b);\n        return c;\n    }\n\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c>=a && c>=b);\n        return c;\n    }\n}\n",
		"./DistributionFace.sol": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.0;\n\n/// @title Distribution Interface - Allows to interact with the distribution.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\ninterface DistributionFace {\n\n    event Subscription(address indexed buyer, address indexed distributor, uint256 amount);\n\n    function subscribe(address _pool, address _distributor, address _buyer) external payable;\n    function setFee(uint256 _fee, address _distributor) external;\n    function getFee(address _distributor) external view returns (uint256);\n}\n"
	},
	"compiler": {
		"name": "solc",
		"version": "0.5.0+commit.1d4f565a",
		"settings": {
			"remappings": [],
			"optimizer": {
				"enabled": true,
				"runs": 200
			},
			"outputSelection": {
				"*": {
					"*": [
						"abi",
						"devdoc",
						"evm.bytecode.object",
						"evm.bytecode.sourceMap",
						"evm.deployedBytecode.object",
						"evm.deployedBytecode.sourceMap"
					]
				}
			}
		}
	},
	"chains": {}
}