{
	"language": "Solidity",
	"sources": {
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/protocol/extensions/adapters/ATotlePrimary.sol": {
			"content": "/*\n\n Copyright 2019 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.4;\npragma experimental ABIEncoderV2;\n\n// https://github.com/ethereum/EIPs/issues/20\ninterface ERC20 {\n    function totalSupply() external view returns (uint supply);\n    function balanceOf(address _owner) external view returns (uint balance);\n    function transfer(address _to, uint _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n    function approve(address _spender, uint _value) external returns (bool success);\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\n    function decimals() external view returns(uint digits);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ninterface WETH {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n\ninterface Oracle {\n\n    function getExpectedRate(\n        ERC20 src,\n        ERC20 dest,\n        uint srcQty,\n        bool usePermissionless)\n        external\n        view\n        returns (uint expectedRate, uint slippageRate);\n}\n\ncontract TotlePrimary {\n    address public tokenTransferProxy;\n}\n\n/// @title Totle Primary adapter - A helper contract for the Totle exchange aggregator.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ncontract ATotlePrimary {\n\n    WETH weth;\n\n    struct Trade {\n        bool isSell;\n        address tokenAddress;\n        uint256 tokenAmount;\n        bool optionalTrade;\n        uint256 minimumExchangeRate;\n        uint256 minimumAcceptableTokenAmount;\n        Order[] orders;\n    }\n\n    struct Order {\n        address exchangeHandler;\n        bytes genericPayload;\n    }\n\n    struct TradeFlag {\n        bool ignoreTrade;\n        bool[] ignoreOrder;\n    }\n\n    constructor(\n        address _weth\n    )\n        public\n    {\n        weth = WETH(_weth);\n    }\n\n    /// @dev Sends transactions to the Totle contract.\n    /// @param trades Array of Structs of parameters and orders.\n    /// @param id Number of the trasactions id.\n    function performRebalance(\n        address totlePrimaryAddress,\n        Trade memory trades,\n        bytes32 id\n    )\n        public\n    {\n        //Trade[] memory checkedTrades = new Trade[](trades.length);\n        //for (uint256 i = 1; i <= trades.length; i++) {\n            //address ETH_TOKEN_ADDRESS = address(0);\n            //address targetTokenAddress = trades[i].tokenAddress;\n            address targetTokenAddress = trades.tokenAddress;\n\n/*\n            address oracleAddress = address(0);\n            Oracle oracle = Oracle(oracleAddress);\n\n            (uint expectedRate, ) = (oracle.getExpectedRate(\n                ERC20(ETH_TOKEN_ADDRESS),\n                ERC20(targetTokenAddress),\n                uint256(0),\n                false\n                )\n            );\n\n            if (expectedRate < trades[i].minimumExchangeRate * 95 / 100)\n                continue;\n\n            if (expectedRate > trades[i].minimumExchangeRate * 105 / 100)\n                continue;\n*/\n\n            //checkedTrades[i] = trades[i];\n            Trade memory checkedTrades = trades;\n\n            // set allowances\n            address tokenTransferProxy = TotlePrimary(totlePrimaryAddress)\n                .tokenTransferProxy();\n            require(\n                setAllowances(\n                    tokenTransferProxy,\n                    targetTokenAddress,\n                    2**256 -1\n                ),\n                \"ALLOWANCE_NOT_SET\"\n            );\n            // TODO: differentiate between buy and sell order\n            weth.deposit.value(trades.tokenAmount)(); // TODO: check exact amount\n        //}\n        address totleAddress = totlePrimaryAddress;\n        (bool success, ) = totleAddress.call(\n            abi.encodeWithSignature(\n                \"performRebalance(Trade[] calldata, bytes32)\",\n                checkedTrades,\n                id\n            )\n        );\n\n        // set allowances back to 0\n        //for (uint256 i = 1; i <= trades.length; i++) {\n            //address targetTokenAddress = trades[i].tokenAddress;\n            //addreess tokenTransferProxy = ... // already defined\n            require(\n                setAllowances(\n                    tokenTransferProxy,\n                    targetTokenAddress,\n                    0\n                ),\n                \"ALLOWANCE_NOT_REVOKED\"\n            );\n        //}\n        require(\n            success,\n            \"CALL_FAILED\"\n        );\n    }\n\n    // TODO: add withdraw residual WETH function\n\n    /*\n     * INTERNAL FUNCTIONS\n     */\n    /// @dev Allows owner to set an infinite allowance to an approved exchange.\n    /// @param tokenTransferProxy Address of the proxy to be approved.\n    /// @param token Address of the token to receive allowance for.\n    /// @param amount Amount to be approved.\n    function setAllowances(\n        address tokenTransferProxy,\n        address token,\n        uint256 amount)\n        internal\n        returns (bool success)\n    {\n        success = false;\n\n        require(\n            ERC20(token)\n            .approve(\n                tokenTransferProxy,\n                amount\n            ),\n            \"ALLOWANCE_SET_UNSUCCESSFUL\"\n        );\n\n        return (success = true);\n    }\n}\n"
		}
	},
	"settings": {
		"remappings": [],
		"optimizer": {
			"enabled": true,
			"runs": 1000000
		},
		"outputSelection": {
			"*": {
				"*": [
					"abi",
					"devdoc",
					"evm.bytecode.object",
					"evm.bytecode.sourceMap",
					"evm.deployedBytecode.object",
					"evm.deployedBytecode.sourceMap"
				]
			}
		},
		"version": "0.5.4+commit.9549d8ff"
	}
}