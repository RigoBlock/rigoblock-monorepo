{
	"language": "Solidity",
	"sources": {
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/tokens/UnlimitedAllowanceToken/UnlimitedAllowanceToken.sol": {
			"content": "pragma solidity 0.5.0;\n\nimport { ERC20 } from \"../ERC20/ERC20.sol\";\n\ncontract UnlimitedAllowanceToken is ERC20 {\n\n    uint256 constant MAX_UINT = 2**256 - 1;\n\n    /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited allowance.\n    /// @param _from Address to transfer from.\n    /// @param _to Address to transfer to.\n    /// @param _value Amount to transfer.\n    /// @return Success of transfer.\n    function transferFrom(address _from, address _to, uint256 _value)\n        external\n        returns (bool)\n    {\n        uint256 allowance = allowed[_from][msg.sender];\n        require(\n            balances[_from] >= _value\n            && allowance >= _value\n            && balances[_to] + _value >= balances[_to]\n        );\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/tokens/ERC20/ERC20.sol": {
			"content": "pragma solidity >=0.5.0;\n\nimport { ERC20Face } from \"./ERC20Face.sol\";\n\ncontract ERC20 is ERC20Face {\n\n    function transfer(address _to, uint256 _value)\n        external\n        returns (bool success)\n    {\n        require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        external\n        returns (bool success)\n    {\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value)\n        external\n        returns (bool success)\n    {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner)\n        external\n        view\n        returns (uint256)\n    {\n        return balances[_owner];\n    }\n\n    function allowance(address _owner, address _spender)\n        external\n        view\n        returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    uint256 public totalSupply;\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/tokens/ERC20/ERC20Face.sol": {
			"content": "pragma solidity >=0.5.0;\n\ninterface ERC20Face {\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function balanceOf(address _who) external view returns (uint256);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/protocol/Vault/Vault.sol": {
			"content": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.0;\n\nimport { AuthorityFace as Authority } from \"../authorities/Authority/AuthorityFace.sol\";\nimport { VaultEventfulFace as VaultEventful } from \"../VaultEventful/VaultEventfulFace.sol\";\nimport { ERC20Face as Token } from \"../../tokens/ERC20/ERC20Face.sol\";\nimport { ReentrancyGuard } from \"../../utils/ReentrancyGuard//ReentrancyGuard.sol\";\nimport { VaultFace } from \"./VaultFace.sol\";\nimport { OwnedUninitialized as Owned } from \"../../utils/Owned/OwnedUninitialized.sol\";\nimport { SafeMathLight as SafeMath } from \"../../utils/SafeMath/SafeMathLight.sol\";\n\n/// @title Vault - contract for creating a vault type of pool.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ncontract Vault is Owned, SafeMath, ReentrancyGuard, VaultFace {\n\n    string constant VERSION = 'VC 0.5.2';\n    uint256 constant BASE = 1000000; //tokens are divisible by 1 million\n\n    VaultData data;\n    Admin admin;\n\n    mapping (address => Account) accounts;\n\n    mapping (address => uint256) totalTokens;\n    mapping (address => mapping (address => uint256)) public depositLock;\n    mapping (address => mapping (address => uint256)) public tokenBalances;\n\n    struct Receipt {\n        uint32 activation;\n    }\n\n    struct Account {\n        uint256 balance;\n        Receipt receipt;\n    }\n\n    struct VaultData {\n        string name;\n        string symbol;\n        uint256 vaultId;\n        uint256 totalSupply;\n        uint256 price;\n        uint256 transactionFee; // fee is in basis points (1 bps = 0.01%)\n        uint32 minPeriod;\n        uint128 validatorIndex;\n    }\n\n    struct Admin {\n        address authority;\n        address vaultDao;\n        address feeCollector;\n        uint256 minOrder; // minimum stake to avoid dust clogging things up\n        uint256 ratio; // ratio is 80%\n    }\n\n    modifier onlyVaultDao {\n        require(msg.sender == admin.vaultDao);\n        _;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier minimumStake(uint256 _amount) {\n        require(_amount >= admin.minOrder);\n        _;\n    }\n\n    modifier hasEnough(uint256 _amount) {\n        require(accounts[msg.sender].balance >= _amount);\n        _;\n    }\n\n    modifier positiveAmount(uint256 _amount) {\n        require(accounts[msg.sender].balance + _amount > accounts[msg.sender].balance);\n        _;\n    }\n\n    modifier minimumPeriodPast {\n        require(now >= accounts[msg.sender].receipt.activation);\n        _;\n    }\n\n    constructor(\n        string memory _vaultName,\n        string memory _vaultSymbol,\n        uint256 _vaultId,\n        address _owner,\n        address _authority)\n        public\n    {\n        data.name = _vaultName;\n        data.symbol = _vaultSymbol;\n        data.vaultId = _vaultId;\n        data.price = 1 ether; //initial price is 1 Ether\n        owner = _owner;\n        admin.authority = _authority;\n        admin.vaultDao = msg.sender;\n        admin.minOrder = 1 finney;\n        admin.feeCollector = _owner;\n        admin.ratio = 80;\n    }\n\n    /*\n     * CORE FUNCTIONS\n     */\n    /// @dev Allows a user to buy into a vault\n    /// @return Bool the function executed correctly\n    function buyVault()\n        external\n        payable\n        minimumStake(msg.value)\n        returns (bool success)\n    {\n        require(buyVaultInternal(msg.sender, msg.value));\n        return true;\n    }\n\n    /// @dev Allows a user to buy into a vault on behalf of an address\n    /// @param _hodler Address of the target user\n    /// @return Bool the function executed correctly\n    function buyVaultOnBehalf(address _hodler)\n        external\n        payable\n        minimumStake(msg.value)\n        returns (bool success)\n    {\n        require(buyVaultInternal(_hodler, msg.value));\n        return true;\n    }\n\n    /// @dev Allows a user to sell from a vault\n    /// @param _amount Number of shares to sell\n    /// @return Bool the function executed correctly\n    function sellVault(uint256 _amount)\n        external\n        nonReentrant\n        hasEnough(_amount)\n        positiveAmount(_amount)\n        minimumPeriodPast\n        returns (bool success)\n    {\n        updatePriceInternal();\n        uint256 feeVault;\n        uint256 feeVaultDao;\n        uint256 netAmount;\n        uint256 netRevenue;\n        (feeVault, feeVaultDao, netAmount, netRevenue) = getSaleAmounts(_amount);\n        addSaleLog(_amount, netRevenue);\n        allocateSaleTokens(msg.sender, _amount, feeVault, feeVaultDao);\n        data.totalSupply = safeSub(data.totalSupply, netAmount);\n        msg.sender.transfer(netRevenue);\n        return true;\n    }\n\n    /// @dev Allows vault dao/factory to change fee split ratio\n    /// @param _ratio Number of ratio for wizard, from 0 to 100\n    function changeRatio(uint256 _ratio)\n        external\n        onlyVaultDao\n    {\n        Authority auth = Authority(admin.authority);\n        VaultEventful events = VaultEventful(auth.getVaultEventful());\n        require(events.changeRatio(msg.sender, address(this), _ratio));\n        admin.ratio = _ratio;\n    }\n\n    /// @dev Allows vault owner to set the transaction fee\n    /// @param _transactionFee Value of the transaction fee in basis points\n    function setTransactionFee(uint256 _transactionFee)\n        external\n        onlyOwner\n    {\n        require(_transactionFee <= 100); //fee cannot be higher than 1%\n        Authority auth = Authority(admin.authority);\n        VaultEventful events = VaultEventful(auth.getVaultEventful());\n        require(events.setTransactionFee(msg.sender, address(this), _transactionFee));\n        data.transactionFee = _transactionFee;\n    }\n\n    /// @dev Allows owner to decide where to receive the fee\n    /// @param _feeCollector Address of the fee receiver\n    function changeFeeCollector(address _feeCollector)\n        external\n        onlyOwner\n    {\n        Authority auth = Authority(admin.authority);\n        VaultEventful events = VaultEventful(auth.getVaultEventful());\n        require(events.changeFeeCollector(msg.sender, address(this), _feeCollector));\n        admin.feeCollector = _feeCollector;\n    }\n\n    /// @dev Allows vault dao/factory to upgrade its address\n    /// @param _vaultDao Address of the new vault dao\n    function changeVaultDao(address _vaultDao)\n        external\n        onlyVaultDao\n    {\n        Authority auth = Authority(admin.authority);\n        VaultEventful events = VaultEventful(auth.getVaultEventful());\n        require(events.changeVaultDao(msg.sender, address(this), _vaultDao));\n        admin.vaultDao = _vaultDao;\n    }\n\n    /// @dev Allows anyone to pay and update the price\n    /// @dev This function allows to write the new nav\n    /// @dev NAV is provided by view functions\n    function updatePrice()\n        external\n        nonReentrant\n    {\n        updatePriceInternal();\n    }\n\n    /// @dev Allows vault dao/factory to change the minimum holding period\n    /// @param _minPeriod Lockup time in seconds\n    function changeMinPeriod(uint32 _minPeriod)\n        external\n        onlyVaultDao\n    {\n        data.minPeriod = _minPeriod;\n    }\n\n    /// @dev Allows anyone to deposit tokens to a vault\n    /// @param _token Address of the token\n    /// @param _value Amount to deposit\n    /// @param _forTime Lockup time in seconds\n    /// @notice lockup time can be zero\n    function depositToken(\n        address _token,\n        uint256 _value,\n        uint8 _forTime)\n        external\n        nonReentrant\n        returns (bool success)\n    {\n        require(depositTokenInternal(_token, msg.sender, _value, _forTime));\n        return true;\n    }\n\n    /// @dev Allows anyone to deposit tokens to a vault on behalf of someone\n    /// @param _token Address of the token\n    /// @param _value Amount to deposit\n    /// @param _forTime Lockup time in seconds\n    /// @notice lockup time can be zero\n    function depositTokenOnBehalf(\n        address _token,\n        address _hodler,\n        uint256 _value,\n        uint8 _forTime)\n        external\n        returns (bool success)\n    {\n        require(depositTokenInternal(_token, _hodler, _value, _forTime));\n        return true;\n    }\n\n    /// @dev Allows anyone to withdraw tokens from a vault\n    /// @param _token Address of the token\n    /// @param _value Amount to withdraw\n    /// @return Bool the transaction was successful\n    function withdrawToken(\n        address _token,\n        uint256 _value)\n        external\n        nonReentrant\n        returns\n        (bool success)\n    {\n        require(tokenBalances[_token][msg.sender] >= _value);\n        require(uint32(now) > depositLock[_token][msg.sender]);\n        tokenBalances[_token][msg.sender] = safeSub(tokenBalances[_token][msg.sender], _value);\n        totalTokens[_token] = safeSub(totalTokens[_token], _value);\n        require(Token(_token).transfer(msg.sender, _value));\n        return true;\n    }\n\n    /*\n     * CONSTANT PUBLIC FUNCTIONS\n     */\n    /// @dev Calculates how many shares a user holds\n    /// @param _from Address of the target account\n    /// @return Number of shares\n    function balanceOf(address _from)\n        external\n        view\n        returns (uint256)\n    {\n        return accounts[_from].balance;\n    }\n\n    /// @dev Returns a user balance of a certain deposited token\n    /// @param _token Address of the token\n    /// @param _owner Address of the user\n    /// @return Number of tokens\n    function tokenBalanceOf(\n        address _token,\n        address _owner)\n        external\n        view\n        returns (uint256)\n    {\n        return tokenBalances[_token][_owner];\n    }\n\n    /// @dev Returns the time needed to withdraw\n    /// @param _token Address of the token\n    /// @param _user Address of the user\n    /// @return Time in seconds\n    function timeToUnlock(\n        address _token,\n        address _user)\n        external\n        view\n        returns (uint256)\n    {\n        return depositLock[_token][_user];\n    }\n\n    /// @dev Returns the amount of tokens of a certain token in vault\n    /// @param _token Address of the token\n    /// @return _value in custody\n    function tokensInVault(address _token)\n        external\n        view\n        returns (uint256)\n    {\n        return totalTokens[_token];\n    }\n\n    /// @dev Gets the address of the logger contract\n    /// @return Address of the logger contrac\n    function getEventful()\n        external\n        view\n        returns (address)\n    {\n        Authority auth = Authority(admin.authority);\n        return auth.getVaultEventful();\n    }\n\n    /// @dev Finds details of a vault pool\n    /// @return String name of a vault\n    /// @return String symbol of a vault\n    /// @return Value of the share price in wei\n    /// @return Value of the share price in wei\n    function getData()\n        external\n        view\n        returns (\n            string memory name,\n            string memory symbol,\n            uint256 sellPrice,\n            uint256 buyPrice\n        )\n    {\n        return(\n            name = data.name,\n            symbol = data.symbol,\n            sellPrice = getNav(),\n            buyPrice = getNav()\n        );\n    }\n\n    /// @dev Returns the price of a pool\n    /// @return Value of the share price in wei\n    function calcSharePrice()\n        external\n        view\n        returns (uint256)\n    {\n        return getNav();\n    }\n\n    /// @dev Finds the administrative data of the pool\n    /// @return Address of the account where a user collects fees\n    /// @return Address of the vault dao/factory\n    /// @return Number of the fee split ratio\n    /// @return Value of the transaction fee in basis points\n    /// @return Number of the minimum holding period for shares\n    function getAdminData()\n        external\n        view\n        returns (\n            address,\n            address feeCollector,\n            address vaultDao,\n            uint256 ratio,\n            uint256 transactionFee,\n            uint32 minPeriod\n        )\n    {\n        return (\n            owner,\n            admin.feeCollector,\n            admin.vaultDao,\n            admin.ratio,\n            data.transactionFee,\n            data.minPeriod\n        );\n    }\n\n    /// @dev Returns the total amount of issued tokens for this vault\n    /// @return Number of shares\n    function totalSupply()\n        external\n        view\n        returns (uint256)\n    {\n        return data.totalSupply;\n    }\n\n    /*\n     * INTERNAL FUNCTIONS\n     */\n    /// @dev Executes purchase function\n    /// @param _hodler Address of the target user\n    /// @return Bool the function executed correctly\n    function buyVaultInternal(\n        address _hodler,\n        uint256 _totalEth)\n        internal\n        returns (bool success)\n    {\n        updatePriceInternal();\n        uint256 grossAmount;\n        uint256 feeVault;\n        uint256 feeVaultDao;\n        uint256 amount;\n        (grossAmount, feeVault, feeVaultDao, amount) = getPurchaseAmounts(_totalEth);\n        addPurchaseLog(amount);\n        allocatePurchaseTokens(_hodler, amount, feeVault, feeVaultDao);\n        data.totalSupply = safeAdd(data.totalSupply, grossAmount);\n        return true;\n    }\n\n    /// @dev Updates the price\n    function updatePriceInternal()\n        internal\n    {\n        if (address(this).balance > 0) {\n            data.price = getNav();\n        }\n    }\n\n    /// @dev Allocates tokens to buyer, splits fee in tokens to wizard and dao\n    /// @param _hodler Address of the buyer\n    /// @param _amount Value of issued tokens\n    /// @param _feeVault Number of shares as fee\n    /// @param _feeVaultDao Number of shares as fee to dao\n    function allocatePurchaseTokens(\n        address _hodler,\n        uint256 _amount,\n        uint256 _feeVault,\n        uint256 _feeVaultDao)\n        internal\n    {\n        accounts[_hodler].balance = safeAdd(accounts[_hodler].balance, _amount);\n        accounts[admin.feeCollector].balance = safeAdd(accounts[admin.feeCollector].balance, _feeVault);\n        accounts[admin.vaultDao].balance = safeAdd(accounts[admin.vaultDao].balance, _feeVaultDao);\n        accounts[_hodler].receipt.activation = uint32(now) + data.minPeriod;\n    }\n\n    /// @dev Destroys tokens from buyer, splits fee in tokens to wizard and dao\n    /// @param _hodler Address of the seller\n    /// @param _amount Value of burnt tokens\n    /// @param _feeVault Number of shares as fee\n    /// @param _feeVaultDao Number of shares as fee to dao\n    function allocateSaleTokens(\n        address _hodler,\n        uint256 _amount,\n        uint256 _feeVault,\n        uint256 _feeVaultDao)\n        internal\n    {\n        accounts[_hodler].balance = safeSub(accounts[_hodler].balance, _amount);\n        accounts[admin.feeCollector].balance = safeAdd(accounts[admin.feeCollector].balance, _feeVault);\n        accounts[admin.vaultDao].balance = safeAdd(accounts[admin.vaultDao].balance, _feeVaultDao);\n    }\n\n    /// @dev Sends a buy log to the eventful contract\n    /// @param _amount Number of purchased shares\n    function addPurchaseLog(uint256 _amount)\n        internal\n    {\n        bytes memory name = bytes(data.name);\n        bytes memory symbol = bytes(data.symbol);\n        Authority auth = Authority(admin.authority);\n        VaultEventful events = VaultEventful(auth.getVaultEventful());\n        require(events.buyVault(msg.sender, address(this), msg.value, _amount, name, symbol));\n    }\n\n    /// @dev Sends a sell log to the eventful contract\n    /// @param _amount Number of sold shares\n    /// @param _netRevenue Value of sale for hodler\n    function addSaleLog(\n        uint256 _amount,\n        uint256 _netRevenue)\n        internal\n    {\n        bytes memory name = bytes(data.name);\n        bytes memory symbol = bytes(data.symbol);\n        Authority auth = Authority(admin.authority);\n        VaultEventful events = VaultEventful(auth.getVaultEventful());\n        require(events.sellVault(msg.sender, address(this), _amount, _netRevenue, name, symbol));\n    }\n\n    /// @dev Executes a deposit\n    /// @param _token Address of the token to be deposited\n    /// @param _hodler Address of the hodler\n    /// @param _value Amount of tokens\n    /// @param _forTime Time in seconds of lockup\n    /// @return Bool the transaction was successful\n    function depositTokenInternal(\n        address _token,\n        address _hodler,\n        uint256 _value,\n        uint8 _forTime)\n        internal\n        returns (bool success)\n    {\n        require(now + _forTime >= depositLock[_token][_hodler]);\n        require(Token(_token).approve(address(this), _value));\n        require(Token(_token).transferFrom(msg.sender, address(this), _value));\n        tokenBalances[_token][_hodler] = safeAdd(tokenBalances[_token][_hodler], _value);\n        totalTokens[_token] = safeAdd(totalTokens[_token], _value);\n        depositLock[_token][_hodler] = safeAdd(uint(now), _forTime);\n        return true;\n    }\n\n    /// @dev Calculates the correct purchase amounts\n    /// @return Number of new shares\n    /// @return Value of fee in shares\n    /// @return Value of fee in shares to dao\n    /// @return Value of net purchased shares\n    function getPurchaseAmounts(uint256 _totalEth)\n        internal\n        view\n        returns (\n            uint256 grossAmount,\n            uint256 feeVault,\n            uint256 feeVaultDao,\n            uint256 amount\n        )\n    {\n        grossAmount = safeDiv(_totalEth * BASE, data.price);\n        uint256 fee = safeMul(grossAmount, data.transactionFee) / 10000; //fee is in basis points\n        return (\n            grossAmount,\n            feeVault = safeMul(fee , admin.ratio) / 100,\n            feeVaultDao = safeSub(fee, feeVault),\n            amount = safeSub(grossAmount, fee)\n        );\n    }\n\n    /// @dev Calculates the correct sale amounts\n    /// @return Value of fee in shares\n    /// @return Value of fee in shares to dao\n    /// @return Value of net sold shares\n    /// @return Value of sale amount for hodler\n    function getSaleAmounts(uint256 _amount)\n        internal\n        view\n        returns (\n            uint256 feeVault,\n            uint256 feeVaultDao,\n            uint256 netAmount,\n            uint256 netRevenue\n        )\n    {\n        uint256 fee = safeMul(_amount, data.transactionFee) / 10000; //fee is in basis points\n        return (\n            feeVault = safeMul(fee, admin.ratio) / 100,\n            feeVaultDao = safeSub(fee, feeVaultDao),\n            netAmount = safeSub(_amount, fee),\n            netRevenue = (safeMul(netAmount, data.price) / BASE)\n        );\n    }\n\n    /// @dev Calculates the value of the shares\n    /// @return Value of the shares in wei\n    function getNav()\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 aum = address(this).balance - msg.value;\n        return (data.totalSupply == 0 ? data.price : safeDiv(aum * BASE, data.totalSupply));\n    }\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/protocol/authorities/Authority/AuthorityFace.sol": {
			"content": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity >=0.4.22 <0.6.0;\n\n/// @title Authority Interface - Allows interaction with the Authority contract.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ninterface AuthorityFace {\n\n    /*\n     * EVENTS\n     */\n    event AuthoritySet(address indexed authority);\n    event WhitelisterSet(address indexed whitelister);\n    event WhitelistedUser(address indexed target, bool approved);\n    event WhitelistedRegistry(address indexed registry, bool approved);\n    event WhitelistedFactory(address indexed factory, bool approved);\n    event WhitelistedVault(address indexed vault, bool approved);\n    event WhitelistedDrago(address indexed drago, bool isWhitelisted);\n    event NewDragoEventful(address indexed dragoEventful);\n    event NewVaultEventful(address indexed vaultEventful);\n    event NewNavVerifier(address indexed navVerifier);\n    event NewExchangesAuthority(address indexed exchangesAuthority);\n\n    /*\n     * CORE FUNCTIONS\n     */\n    function setAuthority(address _authority, bool _isWhitelisted) external;\n    function setWhitelister(address _whitelister, bool _isWhitelisted) external;\n    function whitelistUser(address _target, bool _isWhitelisted) external;\n    function whitelistDrago(address _drago, bool _isWhitelisted) external;\n    function whitelistVault(address _vault, bool _isWhitelisted) external;\n    function whitelistRegistry(address _registry, bool _isWhitelisted) external;\n    function whitelistFactory(address _factory, bool _isWhitelisted) external;\n    function setDragoEventful(address _dragoEventful) external;\n    function setVaultEventful(address _vaultEventful) external;\n    function setNavVerifier(address _navVerifier) external;\n    function setExchangesAuthority(address _exchangesAuthority) external;\n\n    /*\n     * CONSTANT PUBLIC FUNCTIONS\n     */\n    function isWhitelistedUser(address _target) external view returns (bool);\n    function isAuthority(address _authority) external view returns (bool);\n    function isWhitelistedRegistry(address _registry) external view returns (bool);\n    function isWhitelistedDrago(address _drago) external view returns (bool);\n    function isWhitelistedVault(address _vault) external view returns (bool);\n    function isWhitelistedFactory(address _factory) external view returns (bool);\n    function getDragoEventful() external view returns (address);\n    function getVaultEventful() external view returns (address);\n    function getNavVerifier() external view returns (address);\n    function getExchangesAuthority() external view returns (address);\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/protocol/VaultEventful/VaultEventfulFace.sol": {
			"content": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.0;\n\n/// @title Vault Eventful Interface - Logs all vaults transactions.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ninterface VaultEventfulFace {\n\n    /*\n     * EVENTS\n     */\n    event BuyVault(address indexed vault, address indexed from, address indexed to, uint256 amount, uint256 revenue, bytes name, bytes symbol);\n    event SellVault(address indexed vault, address indexed from, address indexed to, uint256 amount, uint256 revenue, bytes name, bytes symbol);\n    event NewRatio(address indexed vault, address indexed from, uint256 newRatio);\n    event NewFee(address indexed vault, address indexed from, address indexed to, uint256 fee);\n    event NewCollector(address indexed vault, address indexed from, address indexed to, address collector);\n    event VaultDao(address indexed vault, address indexed from, address indexed to, address vaultDao);\n    event VaultCreated(address indexed vault, address indexed group, address indexed owner, uint256 vaultId, string name, string symbol);\n\n    /*\n     * CORE FUNCTIONS\n     */\n    function buyVault(address _who, address _targetVault, uint256 _value, uint256 _amount, bytes calldata _name, bytes calldata _symbol) external returns (bool success);\n    function sellVault(address _who, address _targetVault, uint256 _amount, uint256 _revenue, bytes calldata _name, bytes calldata _symbol) external returns(bool success);\n    function changeRatio(address _who, address _targetVault, uint256 _ratio) external returns(bool success);\n    function setTransactionFee(address _who, address _targetVault, uint256 _transactionFee) external returns(bool success);\n    function changeFeeCollector(address _who, address _targetVault, address _feeCollector) external returns(bool success);\n    function changeVaultDao(address _who, address _targetVault, address _vaultDao) external returns(bool success);\n    function createVault(address _who, address _newVault, string calldata _name, string calldata _symbol, uint256 _vaultId) external returns(bool success);\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/utils/ReentrancyGuard/ReentrancyGuard.sol": {
			"content": "/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ReentrancyGuard {\n\n    // Locked state of mutex\n    bool private locked = false;\n\n    /// @dev Functions with this modifer cannot be reentered. The mutex will be locked\n    ///      before function execution and unlocked after.\n    modifier nonReentrant() {\n        // Ensure mutex is unlocked\n        require(\n            !locked,\n            \"REENTRANCY_ILLEGAL\"\n        );\n\n        // Lock mutex before function call\n        locked = true;\n\n        // Perform function call\n        _;\n\n        // Unlock mutex after function call\n        locked = false;\n    }\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/protocol/Vault/VaultFace.sol": {
			"content": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.0;\n\n/// @title Vault Interface - Allows interaction with the Vault contracts.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ninterface VaultFace {\n\n    /*\n     * CORE FUNCTIONS\n     */\n    function buyVault() external payable returns (bool success);\n    function buyVaultOnBehalf(address _hodler) external payable returns (bool success);\n    function sellVault(uint256 amount) external returns (bool success);\n    function changeRatio(uint256 _ratio) external;\n    function setTransactionFee(uint256 _transactionFee) external;\n    function changeFeeCollector(address _feeCollector) external;\n    function changeVaultDao(address _vaultDao) external;\n    function updatePrice() external;\n    function changeMinPeriod(uint32 _minPeriod) external;\n    function depositToken(address _token, uint256 _value, uint8 _forTime) external returns (bool success);\n    function depositTokenOnBehalf(address _token, address _hodler, uint256 _value, uint8 _forTime) external returns (bool success);\n    function withdrawToken(address _token, uint256 _value) external returns (bool success);\n\n    /*\n     * CONSTANT PUBLIC FUNCTIONS\n     */\n    function balanceOf(address _who) external view returns (uint256);\n    function tokenBalanceOf(address _token, address _owner) external view returns (uint256);\n    function timeToUnlock(address _token, address _user) external view returns (uint256);\n    function tokensInVault(address _token) external view returns (uint256);\n    function getEventful() external view returns (address);\n    function getData() external view returns (string memory name, string memory symbol, uint256 sellPrice, uint256 buyPrice);\n    function calcSharePrice() external view returns (uint256);\n    function getAdminData() external view returns (address, address feeCollector, address vaultDao, uint256 ratio, uint256 transactionFee, uint32 minPeriod);\n    function totalSupply() external view returns (uint256);\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/utils/Owned/OwnedUninitialized.sol": {
			"content": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract OwnedUninitialized {\n\n    address public owner;\n\n    event NewOwner(address indexed old, address indexed current);\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function setOwner(address _new) public onlyOwner {\n        require(_new != address(0));\n        owner = _new;\n        emit  NewOwner(owner, _new);\n    }\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/utils/SafeMath/SafeMathLight.sol": {
			"content": "pragma solidity 0.5.0;\n\ncontract SafeMathLight {\n\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b > 0);\n        uint256 c = a / b;\n        assert(a == b * c + a % b);\n        return c;\n    }\n\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c>=a && c>=b);\n        return c;\n    }\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/protocol/VaultEventful/VaultEventful.sol": {
			"content": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.0;\n\nimport { AuthorityFace as Authority } from \"../authorities/Authority/AuthorityFace.sol\";\nimport { VaultEventfulFace } from \"./VaultEventfulFace.sol\";\n\n/// @title Vault Eventful - Logs events for all vaults.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ncontract VaultEventful is VaultEventfulFace {\n\n    string public constant VERSION = 'DH 0.4.2';\n\n    address public AUTHORITY;\n\n    event BuyVault(\n        address indexed vault,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        uint256 revenue,\n        bytes name,\n        bytes symbol\n    );\n\n    event SellVault(\n        address indexed vault,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        uint256 revenue,\n        bytes name,\n        bytes symbol\n    );\n\n    event NewRatio(\n        address indexed vault,\n        address indexed from,\n        uint256 newRatio\n    );\n\n\n    event NewFee(\n        address indexed vault,\n        address indexed from,\n        address indexed to,\n        uint256 fee\n    );\n\n    event NewCollector(\n        address indexed vault,\n        address indexed from,\n        address indexed to,\n        address collector\n    );\n\n    event VaultDao(\n        address indexed vault,\n        address indexed from,\n        address indexed to,\n        address vaultDao\n    );\n\n    event VaultCreated(\n        address indexed vault,\n        address indexed group,\n        address indexed owner,\n        uint256 vaultId,\n        string name,\n        string symbol\n    );\n\n    modifier approvedFactoryOnly(address _factory) {\n        Authority auth = Authority(AUTHORITY);\n        require(auth.isWhitelistedFactory(_factory));\n        _;\n    }\n\n    modifier approvedVaultOnly(address _vault) {\n        Authority auth = Authority(AUTHORITY);\n        require(auth.isWhitelistedVault(_vault));\n        _;\n    }\n\n    modifier approvedUserOnly(address _user) {\n        Authority auth = Authority(AUTHORITY);\n        require(auth.isWhitelistedUser(_user));\n        _;\n    }\n\n    constructor(address _authority) public {\n        AUTHORITY = _authority;\n    }\n\n    /*\n     * CORE FUNCTIONS\n     */\n    /// @dev Logs a Buy Vault event.\n    /// @param _who Address of who is buying\n    /// @param _targetVault Address of the target vault\n    /// @param _value Value of the transaction in Ether\n    /// @param _amount Number of shares purchased\n    /// @return Bool the transaction executed successfully\n    /// @notice transform name and symbol in .js with web3.toAscii(bytes32_date)\n    function buyVault(\n        address _who,\n        address _targetVault,\n        uint256 _value,\n        uint256 _amount,\n        bytes calldata _name,\n        bytes calldata _symbol)\n        external\n        approvedVaultOnly(msg.sender)\n        returns (bool success)\n    {\n        buyVaultInternal(_targetVault, _who, msg.sender, _value, _amount, _name, _symbol);\n        return true;\n    }\n\n    /// @dev Logs a Sell Vault event.\n    /// @param _who Address of who is selling\n    /// @param _targetVault Address of the target vault\n    /// @param _amount Number of shares purchased\n    /// @param _revenue Value of the transaction in Ether\n    /// @return Bool the transaction executed successfully\n    /// @notice transform name and symbol in .js with web3.toAscii(bytes32_date)\n    function sellVault(\n        address _who,\n        address _targetVault,\n        uint256 _amount,\n        uint256 _revenue,\n        bytes calldata _name,\n        bytes calldata _symbol)\n        external\n        approvedVaultOnly(msg.sender)\n        returns(bool success)\n    {\n        require(_amount > 0);\n        sellVaultInternal(_targetVault, _who, msg.sender, _amount, _revenue, _name, _symbol);\n        return true;\n    }\n\n    /// @dev Logswhen rigoblock dao changes fee split.\n    /// @param _who Address of the caller\n    /// @param _targetVault Address of the target vault\n    /// @param _ratio Ratio number from 0 to 100\n    /// @return Bool the transaction executed successfully\n    function changeRatio(\n        address _who,\n        address _targetVault,\n        uint256 _ratio)\n        external\n        approvedVaultOnly(msg.sender)\n        returns(bool success)\n    {\n        require(_ratio > 0);\n        emit NewRatio(_targetVault, _who, _ratio);\n        return true;\n    }\n\n\n    /// @dev Logs a modification of the transaction fee event\n    /// @param _who Address of the caller\n    /// @param _targetVault Address of the target Vault\n    /// @param _transactionFee Value of the transaction fee in basis points\n    /// @return Bool the transaction executed successfully\n    function setTransactionFee(\n        address _who,\n        address _targetVault,\n        uint256 _transactionFee)\n        external\n        approvedVaultOnly(msg.sender)\n        approvedUserOnly(_who)\n        returns(bool success)\n    {\n        emit NewFee(_targetVault, msg.sender, _who, _transactionFee);\n        return true;\n    }\n\n    /// @dev Logs when wizard changes fee collector address\n    /// @param _who Address of the caller\n    /// @param _targetVault Address of the target Vault\n    /// @param _feeCollector Address of the new fee collector\n    /// @return Bool the transaction executed successfully\n    function changeFeeCollector(\n        address _who,\n        address _targetVault,\n        address _feeCollector)\n        external\n        approvedVaultOnly(msg.sender)\n        approvedUserOnly(_who)\n        returns(bool success)\n    {\n        emit NewCollector(_targetVault, msg.sender, _who, _feeCollector);\n        return true;\n    }\n\n    /// @dev Logs a change in the vault dao of an approved vault\n    /// @param _who Address of the caller\n    /// @param _targetVault Address of the vault\n    /// @param _vaultDao Address of the new vault dao\n    /// @return Bool the transaction executed successfully\n    function changeVaultDao(\n        address _who,\n        address _targetVault,\n        address _vaultDao)\n        external\n        approvedVaultOnly(msg.sender)\n        approvedUserOnly(_who)\n        returns(bool success)\n    {\n        emit VaultDao(_targetVault, msg.sender, _who, _vaultDao);\n        return true;\n    }\n\n    /// @dev Logs a new Vault creation by factory\n    /// @param _who Address of the caller\n    /// @param _newVault Address of the new vault\n    /// @param _name String of the name of the new vault\n    /// @param _symbol String of the symbol of the new vault\n    /// @param _vaultId Number of the new vault Id\n    /// @return Bool the transaction executed successfully\n    function createVault(\n        address _who,\n        address _newVault,\n        string calldata _name,\n        string calldata _symbol,\n        uint256 _vaultId)\n        external\n        approvedFactoryOnly(msg.sender)\n        returns(bool success)\n    {\n        createVaultInternal(_newVault, msg.sender, _who, _name, _symbol, _vaultId);\n        return true;\n    }\n\n    /*\n     * INTERNAL FUNCTIONS\n     */\n    /// @dev Logs a purchase event\n    /// @param _who Address of the caller\n    /// @param _targetVault Address of the vault\n    /// @param _factory Address of the factory\n    /// @param _value Value of transaction in wei\n    /// @param _amount Number of new tokens\n    /// @param _name Hex encoded bytes of the name\n    /// @param _symbol Hex encoded bytes of the symbol\n    function buyVaultInternal(\n        address _targetVault,\n        address _who,\n        address _factory,\n        uint256 _value,\n        uint256 _amount,\n        bytes memory _name,\n        bytes memory _symbol)\n        internal\n    {\n        emit BuyVault(_targetVault, _who, _factory, _value, _amount, _name, _symbol);\n    }\n\n    /// @dev Logs a sale event\n    /// @param _who Address of the caller\n    /// @param _targetVault Address of the vault\n    /// @param _factory Address of the factory\n    /// @param _amount Number of burnt tokens\n    /// @param _revenue Value of transaction in wei\n    /// @param _name Hex encoded bytes of the name\n    /// @param _symbol Hex encoded bytes of the symbol\n    function sellVaultInternal(\n        address _targetVault,\n        address _who,\n        address _factory,\n        uint256 _amount,\n        uint256 _revenue,\n        bytes memory _name,\n        bytes memory _symbol)\n        internal\n    {\n        emit SellVault(_targetVault, _who, _factory, _amount, _revenue, _name, _symbol);\n    }\n\n    /// @dev Logs a new vault creation by factory\n    /// @param _who Address of the caller\n    /// @param _newVault Address of the new vault\n    /// @param _factory Address of the factory\n    /// @param _name Bytes array of the name\n    /// @param _symbol Bytes array of the symbol\n    /// @param _vaultId Number of the pool in registry\n    function createVaultInternal(\n        address _newVault,\n        address _factory,\n        address _who,\n        string memory _name,\n        string memory _symbol,\n        uint256 _vaultId)\n        internal\n    {\n        emit VaultCreated(_newVault, _factory, _who, _vaultId, _name, _symbol);\n    }\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/protocol/vaultFactory/VaultFactory/VaultFactory.sol": {
			"content": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.0;\n\nimport { DragoRegistryFace as DragoRegistry } from \"../../DragoRegistry/DragoRegistryFace.sol\";\nimport { AuthorityFace as Authority } from \"../../authorities/Authority/AuthorityFace.sol\";\nimport { VaultEventfulFace as VaultEventful } from \"../../VaultEventful/VaultEventfulFace.sol\";\nimport { VaultFactoryLibrary, Vault } from \"../VaultFactoryLibrary/VaultFactoryLibrary.sol\";\nimport { OwnedUninitialized as Owned } from \"../../../utils/Owned/OwnedUninitialized.sol\";\nimport { VaultFactoryFace } from \"./VaultFactoryFace.sol\";\n\n/// @title Vault Factory contract - allows creation of new vaults.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ncontract VaultFactory is Owned, VaultFactoryFace {\n\n    VaultFactoryLibrary.NewVault private libraryData;\n\n    string public constant VERSION = \"VF 0.5.2\";\n\n    Data private data;\n\n    struct Data {\n        uint256 fee;\n        address vaultRegistry;\n        address payable vaultDao;\n        address authority;\n        mapping(address => address[]) vaults;\n    }\n\n    event VaultCreated(\n        string name,\n        string symbol,\n        address indexed vault,\n        address indexed owner,\n        uint256 vaultId\n    );\n\n    modifier whitelistedFactory(address _authority) {\n        Authority auth = Authority(_authority);\n        require(auth.isWhitelistedFactory(address(this)));\n        _;\n    }\n\n    modifier whenFeePaid {\n        require(msg.value >= data.fee);\n        _;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier onlyVaultDao {\n        require(msg.sender == data.vaultDao);\n        _;\n    }\n\n    constructor(\n        address _registry,\n        address payable _vaultDao,\n        address _authority)\n        public\n    {\n        data.vaultRegistry = _registry;\n        data.vaultDao = _vaultDao;\n        data.authority = _authority;\n        owner = msg.sender;\n    }\n\n    /*\n     * CORE FUNCTIONS\n     */\n    /// @dev allows creation of a new vault\n    /// @param _name String of the name\n    /// @param _symbol String of the symbol\n    /// @return Bool the transaction executed correctly\n    function createVault(string calldata _name, string calldata _symbol)\n        external\n        payable\n        whenFeePaid\n        returns (bool success)\n    {\n        DragoRegistry registry = DragoRegistry(data.vaultRegistry);\n        uint256 regFee = registry.getFee();\n        uint256 vaultId = registry.dragoCount();\n        require(createVaultInternal(_name, _symbol, msg.sender, vaultId));\n        assert(registry.register.value(regFee)(\n            libraryData.newAddress,\n            _name,\n            _symbol,\n            vaultId,\n            msg.sender)\n        );\n        return true;\n    }\n\n    /// @dev Allows factory owner to update the address of the dao/factory\n    /// @dev Enables manual update of dao for single vaults\n    /// @param _targetVault Address of the target vault\n    /// @param _vaultDao Address of the new vault dao\n    function setTargetVaultDao(address _targetVault, address _vaultDao)\n        external\n        onlyOwner\n    {\n        Vault vault = Vault(_targetVault);\n        vault.changeVaultDao(_vaultDao);\n    }\n\n    /// @dev Allows vault dao/factory to update its address\n    /// @dev Creates internal record\n    /// @param _newVaultDao Address of the vault dao\n    function changeVaultDao(address payable _newVaultDao)\n        external\n        onlyVaultDao\n    {\n        data.vaultDao = _newVaultDao;\n    }\n\n    /// @dev Allows owner to update the registry\n    /// @param _newRegistry Address of the new registry\n    function setRegistry(address _newRegistry)\n        external\n        onlyOwner\n    {\n        data.vaultRegistry = _newRegistry;\n    }\n\n    /// @dev Allows owner to set the address which can collect creation fees\n    /// @param _vaultDao Address of the new vault dao/factory\n    function setBeneficiary(address payable _vaultDao)\n        external\n        onlyOwner\n    {\n        data.vaultDao = _vaultDao;\n    }\n\n    /// @dev Allows owner to set the vault creation fee\n    /// @param _fee Value of the fee in wei\n    function setFee(uint256 _fee)\n        external\n        onlyOwner\n    {\n        data.fee = _fee;\n    }\n\n    /// @dev Allows owner to collect fees\n    function drain()\n        external\n        onlyOwner\n    {\n        data.vaultDao.transfer(address(this).balance);\n    }\n\n    /*\n     * CONSTANT PUBLIC FUNCTIONS\n     */\n    /// @dev Returns the address of the pool registry\n    /// @return Address of the registry\n    function getRegistry()\n        external view\n        returns (address)\n    {\n        return (data.vaultRegistry);\n    }\n\n    /// @dev Returns administrative data for this factory\n    /// @return Address of the vault dao\n    /// @return String of the version\n    /// @return Number of the next vault from the registry\n    function getStorage()\n        external view\n        returns (\n            address vaultDao,\n            string memory version,\n            uint256 nextVaultId\n        )\n    {\n        return (\n            vaultDao = data.vaultDao,\n            version = VERSION,\n            nextVaultId = getNextId()\n        );\n    }\n\n    /// @dev Returns the address of the logger contract\n    /// @dev Queries from authority contract\n    /// @return Address of the eventful contract\n    function getEventful()\n        external view\n        returns (address)\n    {\n        Authority auth = Authority(data.authority);\n        return auth.getVaultEventful();\n    }\n\n    /// @dev Returns an array of vaults the owner has created\n    /// @param _owner Address of the queried owner\n    /// @return Array of vault addresses\n    function getVaultsByAddress(address _owner)\n        external view\n        returns (address[] memory)\n    {\n        return data.vaults[_owner];\n    }\n\n    /*\n     * INTERNAL FUNCTIONS\n     */\n    /// @dev Creates a vault and routes to eventful\n    /// @param _name String of the name\n    /// @param _symbol String of the symbol\n    /// @param _owner Address of the owner\n    /// @param _vaultId Number of the new vault Id\n    /// @return Bool the transaction executed correctly\n    function createVaultInternal(\n        string memory _name,\n        string memory _symbol,\n        address _owner,\n        uint256 _vaultId)\n        internal\n        returns (bool success)\n    {\n        Authority auth = Authority(data.authority);\n        require(VaultFactoryLibrary.createVault(\n            libraryData,\n            _name,\n            _symbol,\n            _owner,\n            _vaultId,\n            data.authority)\n        );\n        data.vaults[_owner].push(libraryData.newAddress);\n        VaultEventful events = VaultEventful(auth.getVaultEventful());\n        require(events.createVault(\n            _owner,\n            libraryData.newAddress,\n            _name,\n            _symbol,\n            _vaultId)\n        );\n        auth.whitelistVault(libraryData.newAddress, true);\n        auth.whitelistUser(_owner, true);\n        emit VaultCreated(_name, _symbol, libraryData.newAddress, _owner, _vaultId);\n        return true;\n    }\n\n    /// @dev Returns the next Id for a vault\n    /// @return Number of the next Id from the registry\n    function getNextId()\n        internal view\n        returns (uint256 nextVaultId)\n    {\n        DragoRegistry registry = DragoRegistry(data.vaultRegistry);\n        nextVaultId = registry.dragoCount();\n    }\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/protocol/DragoRegistry/DragoRegistryFace.sol": {
			"content": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.0;\n\n/// @title Drago Registry Interface - Allows external interaction with Drago Registry.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ninterface DragoRegistryFace {\n\n    //EVENTS\n\n    event Registered(string name, string symbol, uint256 id, address indexed drago, address indexed owner, address indexed group);\n    event Unregistered(string indexed name, string indexed symbol, uint256 indexed id);\n    event MetaChanged(uint256 indexed id, bytes32 indexed key, bytes32 value);\n\n    /*\n     * CORE FUNCTIONS\n     */\n    function register(address _drago, string calldata _name, string calldata _symbol, uint256 _dragoId, address _owner) external payable returns (bool);\n    function unregister(uint256 _id) external;\n    function setMeta(uint256 _id, bytes32 _key, bytes32 _value) external;\n    function addGroup(address _group) external;\n    function setFee(uint256 _fee) external;\n    function updateOwner(uint256 _id) external;\n    function updateOwners(uint256[] calldata _id) external;\n    function upgrade(address _newAddress) external payable; //payable as there is a transfer of value, otherwise opcode might throw an error\n    function setUpgraded(uint256 _version) external;\n    function drain() external;\n\n    /*\n     * CONSTANT PUBLIC FUNCTIONS\n     */\n    function dragoCount() external view returns (uint256);\n    function fromId(uint256 _id) external view returns (address drago, string memory name, string memory symbol, uint256 dragoId, address owner, address group);\n    function fromAddress(address _drago) external view returns (uint256 id, string memory name, string memory symbol, uint256 dragoId, address owner, address group);\n    function fromName(string calldata _name) external view returns (uint256 id, address drago, string memory symbol, uint256 dragoId, address owner, address group);\n    function getNameFromAddress(address _pool) external view returns (string memory);\n    function getSymbolFromAddress(address _pool) external view returns (string memory);\n    function meta(uint256 _id, bytes32 _key) external view returns (bytes32);\n    function getGroups() external view returns (address[] memory);\n    function getFee() external view returns (uint256);\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/protocol/vaultFactory/VaultFactoryLibrary/VaultFactoryLibrary.sol": {
			"content": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.0;\n\nimport { AuthorityFace as Authority } from \"../../authorities/Authority/AuthorityFace.sol\";\nimport { Vault } from \"../../Vault/Vault.sol\";\n\n/// @title Vault Factory library - Reduces size of vault factory.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\nlibrary VaultFactoryLibrary {\n\n    struct NewVault {\n        string name;\n        string symbol;\n        uint256 vaultId;\n        address owner;\n        address newAddress;\n    }\n\n    /// @dev Allows an approved factory to create new vaults\n    /// @param _name String of the name\n    /// @param _symbol String of the symbol\n    /// @param _vaultId Number of Id of the vault from the registry\n    /// @param _authority Address of the respective authority\n    /// @return Bool the function executed\n    function createVault(\n        NewVault storage self,\n        string memory _name,\n        string memory _symbol,\n        address _owner,\n        uint256 _vaultId,\n        address _authority)\n        internal\n        returns (bool success)\n    {\n        Vault vault = new Vault(\n            self.name = _name,\n            self.symbol = _symbol,\n            self.vaultId = _vaultId,\n            self.owner = _owner,\n            _authority\n        );\n        self.newAddress = address(vault);\n        return true;\n    }\n}\n"
		},
		"/home/gabriele/rigoblock-monorepo/packages/contracts/src/protocol/vaultFactory/VaultFactory/VaultFactoryFace.sol": {
			"content": "/*\n\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\npragma solidity 0.5.0;\n\n/// @title Vault Factory Interface - Allows external interaction with Vault Factory.\n/// @author Gabriele Rigo - <gab@rigoblock.com>\n// solhint-disable-next-line\ninterface VaultFactoryFace {\n\n    event VaultCreated(string name, string symbol, address indexed vault, address indexed owner, uint256 vaultId);\n\n    function createVault(string calldata _name, string calldata _symbol) external payable returns (bool success);\n    function setTargetVaultDao(address _targetVault, address _vaultDao) external;\n    function changeVaultDao(address payable _newVaultDao) external;\n    function setRegistry(address _newRegistry) external;\n    function setBeneficiary(address payable _vaultDao) external;\n    function setFee(uint256 _fee) external;\n    function drain() external;\n\n    function getRegistry() external view returns (address);\n    function getStorage() external view returns (address vaultDao, string memory version, uint256 nextVaultId);\n    function getEventful() external view returns (address);\n    function getVaultsByAddress(address _owner) external view returns (address[] memory);\n}\n"
		}
	},
	"settings": {
		"remappings": [],
		"optimizer": {
			"enabled": true,
			"runs": 1000000
		},
		"outputSelection": {
			"*": {
				"*": [
					"abi",
					"devdoc",
					"evm.bytecode.object",
					"evm.bytecode.sourceMap",
					"evm.deployedBytecode.object",
					"evm.deployedBytecode.sourceMap"
				]
			}
		},
		"version": "0.5.0+commit.1d4f565a"
	}
}