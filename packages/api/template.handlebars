import * as _ from 'lodash'
import { BigNumber } from 'bignumber.js'
import {
  BlockParam,
  BlockParamLiteral,
  CallData,
  ContractAbi,
  DecodedLogArgs,
  MethodAbi,
  Provider,
  TxData,
  TxDataPayable
} from 'ethereum-types'
import BaseContract from '../baseContract'

const {{{contractName}}}Abi = {{{getAbi ctor events methods}}}

{{!-- {{log methods}} --}}

{{!-- {{#if events}}
export type {{contractName}}EventArgs =
{{#each events}}
    | {{@root.contractName}}{{name}}EventArgs{{#if @last}};{{/if}}
{{/each}}

export enum {{contractName}}Events {
    {{#each events}}
    {{name}} = '{{name}}',
    {{/each}}
}

{{#each events}}
{{> event}}

{{/each}}
{{/if}} --}}
export class {{contractName}} extends BaseContract {
  private abi
  public constructor(web3: any, address: string) {
    super(web3, address, {{{contractName}}}Abi);
    this.abi = {{{contractName}}}Abi
  }

  static async createAndValidate(
    web3: any,
    address: string
  ): Promise<{{contractName}}> {
    const contract = new {{contractName}}(web3, address)
    const code = await web3.eth.getCode(address)

    // in case of missing smartcontract, code can be equal to "0x0" or "0x" depending on exact web3 implementation
    // to cover all these cases we just check against the source code length — there won't be any meaningful EVM program in less then 3 chars
    if (code.length < 4) {
      throw new Error(`Contract at ${address} doesn't exist!`);
    }
    return contract;
  }

  public static address: string
  {{#each methods}}
    {{#this.constant}}
  {{> constantFunction contractName=../contractName}}
    {{/this.constant}}
    {{!-- {{^this.constant}}
    {{> tx contractName=../contractName}}
    {{/this.constant}} --}}
  {{/each}}
  static isDeployed() {
    return !!this.address
  }
}
